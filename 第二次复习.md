##第一章 java的概述<span id="1"></span>
###第一节 java的明天
***
java应用前景非常广泛，PC，手机，银行卡等方面都可以应用
 
###第二节 java的昨天
***
java是由sun公司开发的软件后来被oracle公司收购  
JDK有32位和64位两个版本，32位操作系统只能安装32位的版本。而64位的系统可以安装32位和64位，安装32位需要需要4G内存，但运行速度受到4G内存的限制，64位需要的内存大，但运行速度很快。  
java版本不是越高越好，因为有些版本只是用来测试新性能，测试市场情况。版本不会更新。开发还是需要用一些相对稳定的版本。  
###第三节 java的今天
java的三大分支  
**javaSE 面向PC级的应用开发**  
**javaEE 面向企业级的应用开发**  
**javaME 面向嵌入式应用开发**  
我们主要学习javaSE，其他两个都是根据javaSE改编的。  
**java语言基础内核（本课程主要学习）**  
**基本语句和结构**  
**面向对象的思想（重点）**  
**继承和多态（重点）**  
**异常处理**  
**数据结构**  
**文件处理**  
***
##第二章 java环境搭建
###忽略  
***
###第三章 java类基础知识
###第一节java类结构和main方法  
1类名和文件名相同  
2注释的两种写法（1//单行注释	2/*~*/块注释，可以注释多行）  
3一个java文件中只能有一个public class（且类名必须和文件名一模一样）  
4一个文件可以有多个class，但只能有一个public class（并不提倡在一个文件中放多个class，内部类除外）  
5类是java中最基础的逻辑单位（也就是最小的了）  
6java所有的内容都是需要放在java类的范围中的，不能放在类以外！  
7类的构成（1-成员变量/属性	2-成员方法/函数）  
8一个class文件只能有一个main函数，类可以没有main函数，没有main函数的类不能主动运行，但可以被别人调用。  
9程序的入口都是main函数，严格意义上来说main函数不属于类所拥有的函数，只是java规定所有内容都必须放在类里面，所以main函数**寄居**于类中，main函数无法被其他方法/类调用。  
10一个java程序可以调用多个其他java class  
###第二节 基本类型和运算符  
基本类型（1-Boolean 布尔 2-byte 字节 3-short/int/long 短整数/整数/长整数 4-float/double 浮点数 5-char 字符）  
1-Boolean 只有true和false两种值，默认是false
2-byte字节 1byte=8bits（8位）可以存储最大值127，最小值-128，默认值为0 byte在大型数组中可以显著节省空间呢，因为byte只有int的四分之一。byte在二进制文件读写使用中较多  
<pre>public class Math {
	public static void main(String[] args) {
		byte b = (byte)128;
		System.out.println(b);	//-128
	}
}
</pre>
在这个列子中所赋予的值已经超过最大储存值，所以会被截断为-128
![1][1]  
**整数类型**
short，16位，2个字节（-3w~+3w）默认值为0  
int，32位，4字节（-21亿~+21亿）默认值为0  
long，64位，8字节 默认值为0L（long的末尾要加L）  
**浮点数类型**  
float，单精度，32位，4字节 默认值为0.0f  
double,双精度，64位，8字节 默认值为0.0d  
**float和Double都不能用来表示很精确的数字！**  
**字符类型**  
char是一个单一的16位Unicode字符，最小值为\u000（即为0） 最大值为\uffff（即为65535）  
char数据类型可以储存任何字符  
**运算符**  
+ - * / %  
逻辑运算符 && || ！  
比较运算符 ！=，>,>=,<,<=,==  
移位运算符<<,>>等
***
###选择结构与循环结构
**选择结构**  
if（布尔表达式） 单种case  
if（布尔表达式）else 两种case  
if（布尔） else if （布尔） else  可以多种case  
**注意：if~else if ~else多个分支只会执行其中的一个分支，其他分支会被绕行（及时满足条件）**  
###多种选择结构
switch（表达式）  
-多个case分支  
-满足一个分支后需要break，否则会一直运行下去  
-最后一个分支为default  
###循环结构
while  
do~while  
for  
break 中断循环并退出  
continue 跳出本次循环，继续下次循环  
  <pre>
public class WhileTest {

	public static void main(String[] args) {
		
		System.out.println("=============While Test==========");
		int x = 10;
		while (x < 20) {
			System.out.print("value of x : " + x);
			x++;
			System.out.print("\n");
		}
		
		System.out.println("=============Do  While Test==========");
		x = 10;
		do {
			x++;
			if(x%2 == 0)
			{
				continue;
			}
			System.out.println("value of x : " + x);
		} while (x < 20);
	}

}
</pre>  
<pre>
public class SwitchTest {
	public static void main(String[] args) {
		int a1 = 1;
		int a2 = 2;
		switch(a1+a2)
		{
			case 1: System.out.println("aaaaaaa");
					break;
			case 2: System.out.println("bbbbbbb");
					break;
			case 3: System.out.println("ccccccc");
					//break;	
			default:System.out.println("ddddddd");
		}
		
		String b = "abc";
		switch(b)
		{
			case "abc": System.out.println("eeeeeee");
					break;
			case "def": System.out.println("fffffff");
					break;
			case "hgi": System.out.println("ggggggg");
					break;	
			default:System.out.println("hhhhhhh");
		}

	}

}
</pre>  
###第四节 自定义函数
1函数必须放在类里面  
2**修饰词（public或者static）返回值（int或者void），函数名（形参列表）｛函数体｝**  
3函数可以调用其他函数  
4**递归函数的调用，需要注意终止性**  
<pre>
public class FactorialTest {

	public static void main(String[] args) {
		int a = 5;
		int b = factorialCalculation(a);
		System.out.println("The factorial of " + a + " is " + b);

	}

	public static int factorialCalculation(int m) {
		if (m > 1) {
			return m * factorialCalculation(m - 1); //注意这里和(m-1)的区别，这里会重复调用此函数
		} else {
			return 1;
		}

	}

}
</pre>
###重载
同一个类中**函数名可以相同，但函数的参数或者类型必须有所不同（不能以返回值不同来区分函数）**  
##面向对象和类
###第一节 面向对象思想
####面向对象（1）
-现实世界是由对象和对象相互作用共同组成的  
-每个对象都有自己独特的属性，也有自己专有的方法。外部对象想要调用这些方法，可以向他请求并传入参数，等方法执行结束后，返回结果。  
-对象=属性+方法  
-对象的规范=属性的定义+方法的定义
####对象的调用过程
1.输入参数  
2.等待目标方法执行结束  
3.返回结果
####面向对象（2）
####java中，引入对象和类的概念
-对象是一个变量（具体的东西）  
-类就是**类型（是规范，是定义）**，从万千对象中抽取**共性**  
-类规定了对象应该有的属性和方法  
-对象是类的具体实现，是活生生的  
-例如：土豆丝菜谱是类，一盘土豆丝是对象
-类是定义，规范，是存在纸面上的东西，对象是根据类的定义构造出来的，真实存在的东西
####面向对象（3）
从程序发展的角度来理解，OO（Oriented Object）是对OP（Oriented Procedure）的一种改进  
OP的典型代表是C和Pascal。更强调方法的动作，所有的变量是被动参加进来，没有自主决定权。  
OO方法属于每个对象的，能否实现是由每个对象说了算，有主人翁精神  
<pre>public class OOExample {//OO例子方法是一个对象，而这个对象	可以执行自身的某个方法
	private int a;
	public void setA(int a)
	{
		this.a = a;
	}
	public int add(int b)
	{
		return this.a + b;
	}
	public static void main(String[] a)
	{
		int b = 5;
		OOExample obj = new OOExample();
		obj.setA(10);
		System.out.println(obj.add(b));//主语obj，谓语add，宾语b
		
	}
}
</pre>
<pre>
public class OPExample//OP例子，方法是主体，所以参数类似于宾语
{
   public static void main(String[] args) {
	   int a,b,c;
	   a=1;
       b=2;
       c=add(a,b);
       System.out.println("c is " +c);
   }
   public static int add(int m, int n)  //函数定义
   {
       return m+n;
   }
}
</pre>
####面向对象（5）
变量定义的变迁：更加功能强大  
基本类型（一种变量）=》结构体（多种变量捆绑）=》类（多种变量+方法）。  
类可以继承；子类可以继承父类的所有内容（不能直接访问private成员）  
-**基本类型无法做到/继承（short和int都是整数类型，但是没有继承关系，只是表达的整数范围不同而已）因为继承是类与类的继承**  
-**结构体只能做到全包含，不能控制包含粒度**  
<pre>

public class Son extends Father {
	public void hi() {
		//子类可以扩展自己的成员方法
		System.out.println("hi~~~~~");
	}
	
	public static void main(String[] a)	{
	    Son s = new Son();
	    System.out.println(s.mobile); //Son没有定义mobile, 而是通过父类继承的
	    //System.out.println(s.money); //error 父类的money是私有的，子类无法直接访问
	    s.hello();  //Son没有定义f1, 而是通过父类继承的
	    s.hi();     //Son可以自定义自己的成员方法
	}
}
 class Father {
	 private int money = 100;  //私有
	long mobile = 13999999999L;
	
	public void hello()	{
		System.out.println("hello");
	}
}</pre>
####面向对象（8）
当前最主要的代表是C++和java  
**面向对象语言的主要特点**  
-识认性：辨识一个对象，认定一个对象  
-类别性：把好几种对象归结为一类  
-多态性：在一个类里面，对象有一定的共同性，有一定的不同性  
-继承性：每个子类都可以继承父类的所有东西  
###第二节 java类和对象
####类和对象（1）
-最简单的类 class A｛｝//没有任何属性和行为  
-对象A obj = new A（）;  //可以这样理解  
int a = 5；  
int a = new int（5）；//**右边先new出一个对象赋值给obj，obj是A类型**    
类型 变量名 = new 类型（参数）；  
A obj = new A（）；  
-类是定义，是规范，是“死”的东西  
-对象是实例，是类的一个实现，是一个具体的东西。  
-打个比方（类等价于一个土豆丝菜谱，对象是根据类制作出的对象，等价于一盘土豆丝）  
####类和对象（2）
A obj1 = new A（）；   A obj2 = new A（）；  
以上有两个对象，他们的类型都是A，但是这是两个不同的对象，在内存中有不同的存放地址。因此没有两个对象是完全一致的
![2][2]
####类和对象（3）
A obj = new A（）；  
obj可以看做是内存中的一个对象（包括若干个数据）的句柄  
在c/c++中，obj成为指针，java中称为reference//引用  
对象赋值是reference赋值，而基本类型是直接值拷贝
<pre>
public class ReferenceTest{

	public static void main(String[] args) {
		
		int num1 = 5;
		int num2 = num1;
		System.out.println("num1: " + num1 + ", num2: " + num2);
		num2 = 10;
		System.out.println("num1: " + num1 + ", num2: " + num2);
		
		
		MyNumber obj1 = new MyNumber();
		MyNumber obj2 = new MyNumber();
		System.out.println(obj1.num);
		System.out.println(obj2.num);
		System.out.println("======接下来输出新值=====");
		
		obj2 = obj1;
		obj2.num = 10;
		
		System.out.println(obj1.num);
		System.out.println(obj2.num);

	}

}
class MyNumber{
	int num = 5;
}
</pre>
####类和对象（4）
产生一个对象，A obj = new A（）；  
-99%的情况都是new创建，还有百分之一是用克隆和反射生成  
new出对象后，内部属性的默认值是

|short 0 |int 0 | long 0L|
|:---:|:---:|:---:|
|boolean false|char '\u0000'|byte 0|
|float 0.0f|double 0.0d|
<pre>

public class Initialization {
	
	boolean v1;//类的成员变量，编译器会给默认值，可以直接使用
	byte v2;
	char v3;
	double v4;
	float v5;
	int  v6;
	long v7;
	short v8; 
	
	
	public static void main(String[] args) {
		Initialization obj = new Initialization();
		System.out.println("The initial value of boolean variable is " + obj.v1);//false
		System.out.println("The initial value of byte variable is " + obj.v2);//0
		System.out.println("The initial value of char variable is " + obj.v3);  //\u0000 space
		System.out.println("The initial value of double variable is " + obj.v4);//0.0
		System.out.println("The initial value of float variable is " + obj.v5);//0.0
		System.out.println("The initial value of int variable is " + obj.v6);//0
		System.out.println("The initial value of long variable is " + obj.v7);//0
		System.out.println("The initial value of short variable is " + obj.v8);//0
		
		int a;
		//System.out.println(a);  //error, a 没有初始化
//函数内的局部变量，编译器不会给默认值，需要初始化后才可以使用

	}

}
</pre>
##第四章 面向对象和类（续）
###构造函数
####构造函数（1）
-如何在对象产生时就给成员变量赋值呢？  
-答案就在构造函数里，constructor function
<pre>public class A{
int id ;
public A(int id2){
id = id2;
	}
}
</pre>
-A obj = new A(10);
####构造函数（2）
-java构造函数的名称必须和类名一样，且没有返回值  
-java有构造函数，但是没有析构函数  
-构造函数是制造对象的过程，析构函数是清除对象的过程  
-每个变量都是有生命周期的，它只能储存在离它最近的一对{}中  
-当变量被创建时，变量将占据内存；当变量消亡时，系统将回收内存
####构造函数（3）
-java具有内存回收机制的，当变量退出其生命周期后，JVM会自动回收所分配的对象的内存。所以不需要析构函数来释放内存  
-对象回收效率依赖于垃圾回收器GC
####构造函数（4）
-每个java类都必须有构造函数  
-如果没有显示定义构造函数，java编译器**自动**为该类产生一个**空的无形参**构造函数。如果已经有了显示的有参构造函数，编译器就不会创建  
-每个子类的构造函数的第一句话，都默认调用父类的无参构造函数super(),除非子类的构造函数第一句话是super，而且super语句必须放在第一条。（本条规则会在继承时在提到）
####构造函数（5）
-一个类可以有多个构造函数，只要形参列表不相同即可。  
-在new对象的时候，根据实参的不同，自动挑选相应的构造函数。如果实参形参匹配不上，将会报错
-如果类有构造函数，但没有无参构造函数，编译器不会帮您产生无参构造函数
####第四节 信息隐藏和this
####信息隐藏原则（1）
**面向对象有一个法则：信息隐藏**  
-类的成员属性，是私有的private  
-类的方法是公有public的，通过方法修改成员属性的值  
####信息隐藏原则（3）
**类成员是私有private的**  
get和set方法是公有public的，统称为getter和setter  
外界对类成员的操作只能通过get和set方法  
可以通过java Ide快速生成  
**this的作用**  
1：指向本类中的成员变量  
2：指向本类中的成员方法  
3：可以当做本类的构造函数使用
<pre>class InfoHiding {
	private int id;

	public InfoHiding(int id2) {
		id = id2;
	}
	public int getId() {
		return id;
	}
	public void setId(int id2) {
		id = id2;//看起来很怪，通常不用这个方法
	}
}
</pre>
<pre>
public class InfoHiding2 {
	private int id;
	
	public InfoHiding2(int id)
	{
		this.id = id;//在构造函数里，形参的优先级更高
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}//这个好
}</pre>
<pre>public class MyPairNumber {
	private int m;
	private int n;
	public int getM() {
		return m;
	}
	public void setM(int m) {
		this.m = m;
	}
	public int getN() {
		return n;
	}
	public void setN(int n) {
		this.n = n;
	}	
	public MyPairNumber()	{
		this(0, 0);
	}	
	public MyPairNumber(int m)	{
		this(m, 0);
	}	
	public MyPairNumber(int m, int n)	{
		this.m = m;
		this.n= n;
	}	
	public int sum() {
		return this.add(m,n);  //return add(m,n);  also ok
	}
	public int add(int a, int b){
		return a+b;
	}	
}
</pre>
<pre>

public class Person {
	private int height;
	private int weight;
	private int age;
	private String name;
	
	public int getHeight() {
		return height;
	}
	public void setHeight(int height) {
		this.height = height;
	}
	public int getWeight() {
		return weight;
	}
	public void setWeight(int weight) {
		this.weight = weight;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
</pre>
##第五章 继承接口和抽象类
###第一节 继承
####继承（1）
面向对象编程语言和面向过程的编程语言最突出的优点就是变量类型的继承  
更符合大自然的规律：父亲有的，儿子就有
<pre>
public class Son extends Father
{
	public static void main(String[] a)
	{
	    Son s = new Son();
	    s.f1();  //Son没有定义f1,而是通过父类继承的
	}
}
class Father{
	public void f1() {
		System.out.println("hi");
	}
}</pre>
####继承（3）
面向过程编程语言没有继承，**导致出现很多类型重复定义**  
物以类聚，世间万物皆对象，**对象也可以分成若干类别**  
类别内的对象属性和方法都具有一定的共同点  
将共同点提取出来，即形成了**父类/基类/超类**  
-Parent class/Basic class/Super class  
而其他类自动成为子类/派生类  
-Child class /Derived class
####继承（5）
子类继承父类的所有属性和方法（但不能直接访问private成员）  
根据信息隐藏原则：子类会继承父类的所有方法，可以直接使用（但不能直接访问private成员，可以通过调用父类的方法来访问父类私有变量）  
在同名方法和参数相同的情况下，本类的方法会比父类的方法优先级高
####继承（6）
单根继承原则：每个类都只能继承一个类  
如果不写extends，java类都默认继承java.lang.Object类  
java所以类从java.lang.Object开始，构建一个继承树  
Object类里面默认就有clone，equals，finalize，getClass，hashCode，toString等方法。
####继承（7）
每个java类都必须有构造函数  
-如果没有显示定义构造函数，java编译器**自动**为该类产生一个**空的无形参**构造函数。如果已经有了显示的有参构造函数，编译器就不会创建  
-**每个子类的构造函数的第一句话，都默认调用父类的无参构造函数super(),除非子类的构造函数第一句话是super，而且super语句必须放在第一条。不会出现两条super语句**
<pre>

public class B extends A {
	public B() {
		// super(); 编译器自动增加super()
		System.out.println("333333");
	}

	public B(int a) {
		super(a); // 编译器不会自动增加super();如果不写这条语句，编译器会自动加。输出就会变为1111111111133333333333===========111111111114444444444444444
		System.out.println("444444");
	}

	public static void main(String[] a) {
		B obj1 = new B();
		System.out.println("==============");
		B obj2 = new B(10);
	}

}

class A {
	public A() {
		System.out.println("11111111111111111111111");
	}

	public A(int i) {
		System.out.println("2222222222222222222222222222");
	}
//out:11111111111111111111111
333333
==============
2222222222222222222222222222
444444

}</pre>
####第二节 抽象类和接口
####抽象类（1）
类：属性（0个或多个）+方法（0个或多个）  
一个完整的类：所有的方法都有实现（方法体）  
类可以没有方法，但有方法必须实现，这才是一个完整的类  
一个完整的类才可以	被实例化，被new出来  
如果一个类暂时有方法未实现，需要定义为抽象类
<pre>
public abstract class Shape {
	//面积
	int area;
	
	//计算面积方法
    public abstract void calArea(); //图形未知，所以无法实现
}//抽象类关键字abstract申明  
抽象类的组成  
-成员变量，个数不限  
-具体方法，方法有实现，个数不限  
-抽象方法，加abstract关键字，个数不限
//抽象类可以有方法实现
</pre>
####抽象类（3）
抽象类也是类。一个类继承于抽象类，就不能继承于其他的（抽象）类  
子类可以继承于抽象类，但是一定要实现父类们所有abstract方法，否则子类也会成为抽象类  
只有实现父类的所有abstract方法，才可以变成完整类
<pre>

//继承自Shape抽象类
public class Rectangle extends Shape{

	int width;  //宽
	int length; //长
	
	public Rectangle(int length, int width) {
		this.length = length;
		this.width = width;
	}
	
	public void calArea() {
		System.out.println(this.length * this.width);
	}
	
	public static void main(String[] args) {
		Rectangle rect = new Rectangle(10,5);
		rect.calArea();	
	}
}
abstract class Shape {
	//面积
	int area;
	
	//计算面积方法
    public abstract void calArea(); 
}</pre>
####接口（1）
如果类的所有方法都没有实现，那么这个类就算是接口interface  
类只可以继承（extends）一个类，但是可以实现（implements）多个接口，继承和实现可以同时。但是继承必须放在实现前面  
接口不算累，或者说是“特殊”的类  
接口可以实现，但抽象类不能实现
####接口（2）
接口可以继承（多个）接口，没有实现的方法将会叠加  
类实现接口，就必须实现所有未实现的方法。如果没有全部实现，那么就只能成为一个抽象类  
接口里面可以定义变量，但一般是常量，详细可以参考final节 
####总结
抽象类和接口相同点：两者都不能被实例化，不能被new操作  
抽象类和接口不同点  
-抽象类Abstract，接口interface  
-抽象类可以有部分方法实现，接口所有方法都不能实现  
-一个类只能继承一个（抽象）类，实现多个接口  
接口可以继承（extends）多个接口  
抽象类有构造函数，接口没有构造函数  
抽象类有main，也能运行，接口没有mian函数  
抽象类方法可以有private/protected，接口方法都是public
###第三节 转型，多态，和契约设计
####类转型（1）
变量支持相互转化，比如int a = （int）3.5；  
类型可以相互转型，但是只限于有继承关系的类  
-**子类可以转型为父类，而父类不能转型为子类**   
-子类继承父类的所有遗产，子类可以变成父类（从大变小，即向上转型）；从父类直接变成子类（从小变大，即向下转型）则不允许
<pre>
Human obj1 = new Man(); //OK Man extends Human 
Man obj2 = new Human();//illegal,man is derived class Huamn
</pre>
####类转型（2）
父类转换为子类有一种情况是列外的  
-就是父类本身就是从子类转换过来的
<pre>
Human obj1 = new Man();//定义出一个Man，转型为Human。obj1就是human类型
Man obj2 = (Man)obj1;//将Human类型强转为man，却没有报错，是因为obj1最开始就是man类型
</pre>
####多态（1）
类型转换，带来的作用就是多态  
子类继承父类的所有方法，但子类可以重新定义一个名字，参数和父类一样的方法，这种行为就是重写（覆写，覆盖，不是重载）//重载是指函数名一样，形参不一样  
子类的方法的优先级高于父类的  
<pre>
public class Man extends Human {
	public void eat() {
		System.out.println("I can eat more");
	}
	
	public void plough() { }

	public static void main(String[] a)	{
		Man obj1 = new Man();//obj1是man类型，所以自然调用的man中的eat方法
		obj1.eat();   // call Man.eat()
		Human obj2 =  (Human) obj1;//obj2转型前是obj1，而obj1是man类型，所以obj2本质上是man类型
		obj2.eat();   // call Man.eat()
		Man obj3 = (Man) obj2;//obj2本身也是脱胎于obj1
		obj3.eat();	  // call Man.eat()
	}
}
</pre>
####多态（3）
多态的作用：  
-以统一的接口来操作某一类中不同对象的动态行为  
-对象之间的解耦  
     
	 public class Dog implements Animal
    {
	public void eat() {
		System.out.println("Dog: I can eat");
	}
	
	public void move() {
		System.out.println("Dog: I can move");
	}
    }
***


	public class Cat implements Animal
	{
	public void eat() {
		System.out.println("Cat: I can eat");
	}
	
	public void move(){
		System.out.println("Cat: I can move");
	}
	}
***
		public interface Animal {
		public void eat();
		public void move();
		}

***
	public class AnimalTest {
	
	public static void haveLunch(Animal a)	{
		a.eat();
	}
	
	public static void main(String[] args) {
		Animal[] as = new Animal[4];
		as[0] = new Cat();//隐形做了一次类转型
		as[1] = new Dog();
		as[2] = new Cat();
		as[3] = new Dog();
		
		for(int i=0;i<as.length;i++) {
			as[i].move();  //调用每个元素的自身的move方法
		}
		for(int i=0;i<as.length;i++) {
			haveLunch(as[i]);
		}
		
		haveLunch(new Cat());  //隐形做了一次转型Animal  a = new Cat();  haveLunch(a);
		haveLunch(new Dog());
		haveLunch(
				new Animal()//new了一个接口，必须把接口所有未完成的方法完成，隐形定义了一次匿名类
				{
					public void eat() {
						System.out.println("I can eat from an anonymous class");						
					}
					public void move() {
						System.out.println("I can move from an anonymous class");
					}
					
				});
	}
	}

	
####契约设计（1）
java编程设计遵循契约精神  
契约：规定规范了对象应该包含的行为方法  
接口定义了方法的名称，参数和返回值，规范了派生类的行为  
基于接口，利用类转型和多态，不影响真正方法的调用，成功地将调用类和被调用类解耦  
##第六章 static final和常量设计
###第一节 static
####static（1）
static静态的，java中特殊的关键字  
java中的static关键字（可作用在）  
-变量  
-方法  
-类  
-匿名方法块  
[https://blog.csdn.net/ecnuThomas/article/details/54954234](https://blog.csdn.net/ecnuThomas/article/details/54954234 "匿名代码块知识点")
####static（2）
静态变量，类共有成员  
-static变量只依赖于类存在（通过类即可访问），不依赖于对象实例存在。即可通过Potato.price即可访问  
-所有的对象实例，如例子中的obj1和obj2关于price变量的值都共享存储在共同的空间（我）
	
	public class Potato {
	static int price = 5;
	String content = "";
	public Potato(int price, String content)
	{
		this.price = price;
		this.content = content;
	}	
	public static void main(String[] a)
	{
		System.out.println(Potato.price); //Potato.content    wrong
		System.out.println("----------------------------------");
		Potato obj1 = new Potato(10,"青椒土豆丝");
		System.out.println(Potato.price);
		System.out.println(obj1.price);
		
		System.out.println("----------------------------------");
		Potato obj2 = new Potato(20,"酸辣土豆丝");
		System.out.println(Potato.price);
		System.out.println(obj2.price);
		
	}
	}
***
static（3）  
static方法  
-静态方法也无需通过对象来引用，而通过类名可以直接引用  
-在静态方法中，只能使用静态变量，不能使用非静态变量  
-静态方法禁止引用非静态方法  
关于static修饰类（内部类），使用的机会较少，暂忽略不计。 
	
	public class StaticMethodTest {
	int a = 111111;
	static int b = 222222;
	int c = 33333;
	public static void hello()
	{
		System.out.println("000000");
		System.out.println(b);
		//System.out.println(c);	//error,静态方法不能调用非静态变量
		//System.out.println(a);  //error, cannot call non-static variables
		//hi()                    //error, cannot call non-static method
	}
	public void hi()
	{
		System.out.println("333333");
		hello();                  //ok, call static methods		非静态方法可以调用静态方法，静态方法则不能调用非静态方法
		System.out.println(a);    //ok, call non-static variables
		System.out.println(b);    //ok, call static variables
	}
	public static void main(String[] a)
	{
		StaticMethodTest.hello();
		//StaticMethodTest.hi(); //error, 不能使用类名来引用非静态方法
		StaticMethodTest foo = new StaticMethodTest();
		foo.hello();  //warning, but it is ok
		foo.hi();     //right
	}
	}
****
####static（4）
static块  
-只在类第一次被加载时调用  
-换句话说，在程序运行期间，这段代码只运行一次  
-执行顺序：static块>匿名块>构造函数  
	public class StaticBlockTest {

	public static void main(String[] args) {
		System.out.println("000000000000000");
		// TODO Auto-generated method stub
		StaticBlock obj1 = new StaticBlock();
		StaticBlock obj2 = new StaticBlock();
	}

	}
	class StaticBlock
	{
	//staticl block > anonymous block > constructor function	
	static
	{
		System.out.println("22222222222222222222");
	}
	{
		System.out.println("11111111111111111111");
	}
	public StaticBlock()
	{
		System.out.println("33333333333333333333");
	}
	{
		System.out.println("44444444444444444444");
	}
	}
	//out000000000000000
	22222222222222222222由于是static匿名块，所以只执行一次
	11111111111111111111
	44444444444444444444
	33333333333333333333
	11111111111111111111
	44444444444444444444
	33333333333333333333
***
###第二节 单列模式
####单列模式（1）
单列模式，又名单态模式  
限定某一类在整个程序运行过程中，只能保留一个实例对象在内存空间  
单例模式是GoF的23种设计模式中经典的一种，属于创建型模式
####单例模式（3）
单例模式：保证一个类有且只有一个对象  
-采用static来共享对象实例  
-采用private构造函数，防止外界new操作

	public class Singleton {
	private static Singleton obj = new Singleton(); //共享同一个对象
	private String content;
	
	private Singleton()  //确保只能在类内部调用构造函数
	{
		this.content = "abc";
	}
	
	public String getContent() 	{
		return content;
	}
	public void setContent(String content) {
		this.content = content;
	}	
	
	public static Singleton getInstance()	{
		//静态方法使用静态变量
		//另外可以使用方法内的临时变量，但是不能引用非静态的成员变量
		return obj;
	}
	
	
	public static void main(String[] args) {
		Singleton obj1 = Singleton.getInstance();
		System.out.println(obj1.getContent());  //abc
		
		Singleton obj2 = Singleton.getInstance();
		System.out.println(obj2.getContent());  //abc
		
		obj2.setContent("def");
		System.out.println(obj1.getContent());
		System.out.println(obj2.getContent());
		
		System.out.println(obj1 == obj2); //true, obj1和obj2指向同一个对象
	}

	}
***
###第三节 final
####final
java的final关键字同样可用来修饰  
-类  
-方法  
-字段  
final的类，不能被继承  
父类中如果有final的方法，子类中不能改写此方法

	final public class FinalFather {
	
	}
	class Son1 extends FinalFather	error不能继承final类
	{
	
}
***
	public class FinalMethodSon extends FinalMethodFather{
	public void f1()	error，不能重写final方法
	{
		
	}
	}
	 class FinalMethodFather {
	public final void f1()
	{
		
	}
	}
####final
final的变量，不能再次赋值  
-如果是基本型别的变量，不能修改其值；  
-如果是对象实例，那么不能修改其指针（但是可以修改对象内部的值）

	class FinalObject
	{
	int a = 10;
	}
	public class FinalObjectTest {
	public static void main(String[] args) {
		final FinalObject obj1 = new FinalObject();
		System.out.println(obj1.a);
		obj1.a = 20;
		System.out.println(obj1.a);
		
		obj1 = new FinalObject();
		//final对象不能变更指针，可以改变对象里面的数值。final的对象的指针固定了，因此只能修改对象内部的值，而不能指向一个新的对象（内存空间）
	}

	}

###第四节 常量设计和常量池
####常量设计（1）
**常量：一种不会修改的变量**  
-java没有constant关键字  
-不能修改，final  
-不会修改/只读/只要一份，static  
-方便访问public  
**java中的常量**  
-public static final  
-建议变更名字全大写，以连字符相连，如UPPER_BOUND

	public class Constants {
	public final static double PI_NUMBER = 3.14;
	public static final String DEFAULT_COUNTRY="China";//static和final可以颠倒顺序
	
	public static void main(String[] a)
	{
		System.out.println(Constants.PI_NUMBER);
		System.out.println(Constants.DEFAULT_COUNTRY);//如果变量时static且final的，static保证只有一份，final保证值不会被修改，那么这个变量就是常量。
	}
	}
***
####常量设计（3）
一种特殊的常量：接口内定义的变量默认是常量

	public interface SpecialAnimal {
	String color = "yellow"; //default: public static final
	public void move();//实现接口，就需要遵循接口的定义，就是尊重契约精神。所以接口的变量就是以常量的形式存在
	}
***
	public class Cat implements SpecialAnimal {
	public void move() {
		System.out.println("I can move");
	}

	public static void main(String[] args) {
		Cat cat = new Cat();
		cat.color = "white";  //error, the variables in interface are constants.接口内的值是常量，不能被修改
	}
	}

###常量池（1）
首先请猜一猜下列程序的输出结果

	public class IntegerTest {

	public static void main(String[] args) {
		Integer n1 = 127;
		Integer n2 = 127;
		System.out.println(n1==n2); 
		//对象双等号是比较指针是否指向同一个东西
		
		Integer n3 = 128;
		Integer n4 = 128;
		System.out.println(n3==n4);
		
		Integer n5 = new Integer(127);
		System.out.println(n1==n5);
	}

	}
***
###常量池（2）
java为很多基本类型的包装类/字符串都建立常量池  
常量池：相同的值只存储一份，节省内存，共享访问  
**基本类型的包装类**  
-Boolean，Byte，Short，Integer，Long，Character，**Float，Double**  
-Boolean：true，false  
-Byte：-128~127，Character：0~127  
-Short，Int，Long：-128~127  
-**Float,Double:没有缓存（常量池）**  

###常量池（3）
java为常量字符串都建立常量池缓存机制  
**字符串常量**
###常量池（4）
**基本类型的包装类和字符串有两种创建方式**  
常量式（字面量）赋值创建，放在栈内存**（将被常量化）**  
-Integer a = 10;  
-String b = "abc";  
-new对象进行创建，放在堆内存**（不会被常量化）**  
Integer c = new Integer（10）；  
String d = new String（“abc”）；  
**这两种创建方式导致创建的对象存放的位置不同**  
常量池的作用：1，节约内存 2，共享访问  
**栈内存读取速度快但容量小  
堆内存读取速度慢但容量大**  

###常量池（5）  
**查看BoxClassTest.java 分析Integer类**  
-基本类型和包装类比较，将对包装类自动拆箱  
-对象比较，比较地址  
-加法+会自动拆箱  

	
	public class BoxClassTest {
	public static void main(String[] args)
	{
		int i1 = 10;
		Integer i2 = 10;                // 自动装箱
		System.out.println(i1 == i2);   //true
		// 自动拆箱  基本类型和包装类进行比较，包装类自动拆箱
		
		Integer i3 = new Integer(10);
		System.out.println(i1 == i3);  //true
		// 自动拆箱  基本类型和包装类进行比较，包装类自动拆箱
		
		System.out.println(i2 == i3); //false
		// 两个对象比较，比较其地址。 
		// i2是常量，放在栈内存常量池中，i3是new出对象，放在堆内存中
		
		Integer i4 = new Integer(5);
		Integer i5 = new Integer(5);
		System.out.println(i1 == (i4+i5));   //true
		System.out.println(i2 == (i4+i5));   //true
		System.out.println(i3 == (i4+i5));   //true
		// i4+i5 操作将会使得i4,i5自动拆箱为基本类型并运算得到10. 
		// 基础类型10和对象比较, 将会使对象自动拆箱，做基本类型比较
		
		Integer i6 = i4 + i5;  // +操作使得i4,i5自动拆箱，得到10，因此i6 == i2.
		System.out.println(i1 == i6);  //true
		System.out.println(i2 == i6);  //true
		System.out.println(i3 == i6);  //false
	}	
	}
**查看StringNewTest.java 分析String类**  
-常量赋值（堆内存）和new创建（栈内存）不是同一个对象  
-编译器只会优化确定的字符串，并缓存  
	
	public class StringNewTest {
	public static void main(String[] args) {
		String s0 = "abcdef";
		String s1 = "abc";
		String s2 = "abc";
		String s3 = new String("abc");
		String s4 = new String("abc");
		System.out.println(s1 == s2); //true 常量池
		System.out.println(s1 == s3); //false 一个栈内存，一个堆内存
		System.out.println(s3 == s4); //false 两个都是堆内存
		System.out.println("=========================");
		
		String s5 = s1 + "def";    //涉及到变量，故编译器不优化
		String s6 = "abc" + "def"; //都是常量 编译器会自动优化成abcdef
		String s7 = "abc" + new String ("def");//涉及到new对象，编译器不优化
		System.out.println(s5 == s6); //false
		System.out.println(s5 == s7); //false
		System.out.println(s6 == s7); //false
		System.out.println(s0 == s6); //true 
		System.out.println("=========================");

		
		String s8 = s3 + "def";//涉及到new对象，编译器不优化
		String s9 = s4 + "def";//涉及到new对象，编译器不优化
		String s10 = s3 + new String("def");//涉及到new对象，编译器不优化
		System.out.println(s8 == s9); //false
		System.out.println(s8 == s10); //false
		System.out.println(s9 == s10); //false
	}
	}

###第五节 不可变对象和字符串
####不可变对象（1）
**不可变对象**  
-一旦创建，这个对象（状态/值）不能更改了  
-其内在的成员变量的值就不能修改了  
-八个基本型别的包装类  //不可变对象是指对象不再修改，即abc不会被修改，而指针（句柄/变量名）的指向可以修改
-String，BigInteger和BigDecimal等  
**可变对象**  
普通对象
####不可变对象（2）
不可变对象，也是传指针（引用）  
由于不可变，临时变量指向新内存，外部  
实参的指针不改动
####不可变对象（3）
**如何创建不可变对象**  
-immutable对象是不可改变，有改变，请clone/new一个对象进行修改  
-所有的属性都是final和private的  
-不提供setter方法  
-类是final的，或者所有的方法都是final  
-类中包含mutable对象，那么返回拷贝需要深度clone
####不可变对象（4）
**不可变对象优点**  
-只读，线程安全  
-并发读，提高性能  
-可以重复使用  
**缺点**  
-制造垃圾，浪费空间  
对不可变对象进行修改时，会新开辟空间，旧对象则被搁置，直到垃圾回收  
####java字符串（1）
字符串是java使用最多的类，是一种典型的不可变对象  
String定义有两种  
-String a = “abc”；//常量赋值，栈分配内存  
-String b = new String（“abc”）；//new对象，堆分配内存  
字符串内容比较：equals方法  
是否指向同一个对象：指针比较==
####java字符串（2）
**java常量池**  
-保存在编译期间就已经确定的数据  
-是一块特殊的内存  
-相同的**常量字符串**只存储一份，节省内存，共享访问//是常量字符串，new出来的不算
####java字符串（3）
字符串的加法  
String a = “abc”；  
a = a+“def”;//由于String不可修改，效率差  
使用StringBUffer/StringBuilder类的append方法进行修改  
StringBuffer/StringBuilder的对象都是可变对象  
StringBuffer（同步，线程安全，修改快速），StringBuilder（不同步，线程不安全，修改更快）
##第七章 package，import和classpath
###第一节package和import
####package（1）
**所有的java类都是放置在同一个目录下面的，因此类之间的相互调用无需显示声明调用**
-同一个目录下，两个类名字不能相同  
-文件过多，查找和修改都不易，且容易出错  
**java支持多个目录放置java，并且通过**  
package/import/classpath/jar等机制配合使用，可以支持跨目录放置和调用java类
####package（2）
package包，和c++中的namespace类似  
在java类文件的第一句话给出包的名称 
 
	//cn/edu/ecnu/PackageExample.java
	package cn.edu.ecnu;
	public class PackageExample{}

类全称cn.edu.ecnu.PackageExample，短名称PackageExample  
引用类的时候，必须采用全称引用；程序正文可以用短名称  
PackageExample.java必须严格放置在cn/edu/ecnu目录下
####package（3）
包名package name尽量唯一  
域名是唯一的，因此常用域名做包名  
域名逆序：cn.edu.ecnu，范围通常从大到小  
类的完整名字：包名+类名，cn.edu.ecnu.PackageExample  
包名：**和目录层次一样**，cn/edu/ecnu/PackageExample.java  
但是包具体放在什么位置不重要，编译和运行的时候再指定  
####import（1）
在PackageExampleTest.java中，可用import关键字来引入PackageExample类  

	package cn.edu.ecnu;
	import cn.edu.ecnu.PackageExample;
	//也可以采用import cn.edu.ecnu.*
	//"*"代表这个目录下所有的文件，但不包括文件夹和子文件夹内的文件
	public class PackExampleTest{
	public static void main(String[] args){
	PackageExample obj = new Packageexample（）；
	//此处可以用短名称
	}
	}

####import（2）
**import规则**  
-import必须全部放在package之后，类定义之前。  
-多个import的顺序无关。  
-可以用“※”来引入一个目录下的所有类，不如import java.lang.*；但不包括各个目录下的文件  
-import尽量精确，不推荐用※，以免新增的同名程序会使得老程序报错
###第二节 jar文件的导入和导出
####jar（1）
jar文件，一种扩展名为jar的文件，是java特有的一种文件格式，用于可执行文件的传播  
jar文件实际上是一组class文件的压缩包
####jar（2）
**jar文件优势**  
-jar文件可以包括多个class文件，比多层目录更加简洁实用  
-jar文件经过压缩，只有一个文件，在网络传播方面，更具有优势  
-jar文件只包含class文件，而不包括java文件，在保护源文件知识产权方面起到很好的作用  
-将多个class文件压缩成jar文件，可以规定一个版本号，更容易进行版本控制
###第三节 package和import命令
####package和import（1）
java支持多个目录放置java，并且通过package/import/classpath/jar等机制配合使用，可以支持多处地方放置和调用java类。  
利用eclipse和IDE可以快速生成包，类和jar文件，可以快捷import所需要的class
###第四节 java访问权限
####java访问权限（1）
**java访问权限有四种**  
-private：私有的，只能本类访问  
-default：（通常忽略不写）同一个包内访问  
-protected：同一个包，子类均可以访问  
-public：公开的，所有类可以访问  
**使用范围**  
-四种都可以用来修饰成员变量，成员方法，构造函数  
-default和public可以修饰类
####java访问权限（2）
|-|同一个类|同一个包|不同包的子类|不同包的非子类|
|:---:|:---:|:---:|:---:|:---:|
|private|√|
|default|√|√
|protected|√|√|√
|public|√|√|√|√

	package test1;

	public class A {
	private int v1 = 1;
	int v2 = 2;
	protected int v3 = 3;
	public int v4 = 4;
	
	private void showV1() 
	{
		System.out.println(v1);
	}
	void showV2()
	{
		System.out.println(v2);
	}
	protected void showV3()
	{
		System.out.println(v3);
	}
	public void showV4()
	{
		System.out.println(v4);
	}
	}

***
	package test1;

	//B and A are in the same package
	public class B {//b不是a的子类，所以无法直接访问成员变量和成员方法
	public void show()
	{
		//B is not subclass of A
	//		System.out.println(v1);  //error
	//		System.out.println(v2);  //error
	//		System.out.println(v3);  //error
	//		System.out.println(v4);  //error		
	//		showV1();   //error
	//		showV2();   //error
	//		showV3();   //error
	//		showV4();   //error
		
		A obj = new A();//a类的private成员不能对外分享，但是default/protected/public的成员可以被同一个包的其他类访问
		//System.out.println(obj.v1);   error,  private
		System.out.println(obj.v2);
		System.out.println(obj.v3);
		System.out.println(obj.v4);
		
		//obj.showV1();   error,  private
		obj.showV2();
		obj.showV3();
		obj.showV4();
	}
	}
***

	package test1;

	//C is a subclass of A, and in the same package of A.
	public class C extends A {//子类继承父类的所有东西，但是不能访问private
	public void show()
	{		
		//System.out.println(v1);  error, private
		System.out.println(v2);
		System.out.println(v3);
		System.out.println(v4);		
		//showV1();  error, private
		showV2();
		showV3();
		showV4();
		//第七到十四行，c类以a类的子类身份，来访问a类的成员	第十六到二十五行，c类以a类同包平等的身份，来访问a类的成员（就是按照包的关系走的）
		A obj = new A();//通过新建a的对象，通过对象访问a类的内容，这个时候，b类和a类的private的成员依旧无法访问，其他的default/protected/public成员可以被同包的类访问
		//System.out.println(obj.v1);   error,  private
		System.out.println(obj.v2);
		System.out.println(obj.v3);
		System.out.println(obj.v4);
		
		//obj.showV1();   error,  private
		obj.showV2();
		obj.showV3();
		obj.showV4();
	}
	}
***

	package test2;

	import test1.A;

	public class D extends A{
	public void show()
	{		
		//System.out.println(v1);  error, private
		//System.out.println(v2);  error, default
		System.out.println(v3);
		System.out.println(v4);		
		//showV1();  error, private
		//showV2();  error, default
		showV3();
		showV4();
		
		A obj = new A();
		//System.out.println(obj.v1);   error,  private
		//System.out.println(obj.v2);   error,  default
		//System.out.println(obj.v3);   error,  protected 只能作为子类才能访问   
		System.out.println(obj.v4);
		
		//obj.showV1();   error,  private
		//obj.showV2();   error,  default
		//obj.showV3();   error   protected 只能作为子类才能访问
		obj.showV4();
	}
	}
***
	package test2;

	import test1.A;

	public class E {
	public void show()
	{		
		//E is not a subclass of A. And E is not in the same package of A.
		//System.out.println(v1);  error, private
		//System.out.println(v2);  error, default
		//System.out.println(v3);
		//System.out.println(v4);		
		//showV1();  error, private
		//showV2();  error, default
		//showV3();
		//showV4();
		
		A obj = new A();
		//System.out.println(obj.v1);   error,  private
		//System.out.println(obj.v2);   error,  default
		//System.out.println(obj.v3);   error,  protected 只能作为子类才能访问   
		System.out.println(obj.v4);
		
		//obj.showV1();   error,  private
		//obj.showV2();   error,  default
		//obj.showV3();   error   protected 只能作为子类才能访问
		obj.showV4();
	}
	}
##第八章 java常用类
###第一节 java类库概述
没啥
###第二节 数字相关类
####数字类
**java数字类**  
-整数 short，int，long  
-浮点数 float，Double  
-大数类 bigInteger（大整数），bigdecimal（大浮点数）  
-随机数类 random  
-工具类 math  
**java.math**包  
####整数类型（1）
**整数类型**
short，16位，2个字节（-3w~+3w）默认值为0  
int，32位，4字节（-21亿~+21亿）默认值为0  
long，64位，8字节 默认值为0L（long的末尾要加L）  
**浮点数类型**  
float，单精度，32位，4字节 默认值为0.0f  
double,双精度，64位，8字节 默认值为0.0d  
**float和Double都不能用来表示很精确的数字！**   
基本类型和包装类表示的范围都一样

	package test1;

	public class A {
	public static void main(String[] args) {
	short a1 = 32767;
	System.out.println(a1);
	//short a2 = 32768 error 越界
	int b1 = 2147483647;
	System.out.println(b1);
	//int b2 = 2147483648 error 越界
	long c1 = 1000000000l;
	System.out.println(c1);
	long c2 = 2147483647;//隐形做了一次int转为long的操作
	System.out.println(c2);
	
	}
	}
***
	public class FloatingTest {
	public static void main(String[] args) {
		float f1 = 1.23f;
		// float f2 = 1.23;  error, float赋值必须带f
		double d1 = 4.56d;
		double d2 = 4.56;  //double 可以省略末尾d
		
		System.out.println(f1); //1.23
		System.out.println((double)f1); //转换到double, 输出1.2300000190734863
		System.out.println(d1); //4.56
		System.out.println((float)d2); //4.56
		
		System.out.println(f1==1.229999999f); //true
		System.out.println(f1-1.229999999f); //0.0
		System.out.println(d2==4.559999999999999999d); //true
		System.out.println(d2-4.559999999999999999d); //0.0			
	}
	}
####大数字类
**大整数类bigInteger**  
-支持无限大的整数运算  
	
	import java.math.BigInteger;

	public class BigIntegerTest {

	public static void main(String[] args) {
		BigInteger b1 = new BigInteger("123456789"); // 声明BigInteger对象
		BigInteger b2 = new BigInteger("987654321"); // 声明BigInteger对象
		System.out.println("b1: " + b1 +  ", b2:" + b2);
		System.out.println("加法操作：" + b2.add(b1)); // 加法操作
		System.out.println("减法操作：" + b2.subtract(b1)); // 减法操作,只能通过这种方法，不能使用+
		System.out.println("乘法操作：" + b2.multiply(b1)); // 乘法操作
		System.out.println("除法操作：" + b2.divide(b1)); // 除法操作
		System.out.println("最大数：" + b2.max(b1)); // 求出最大数
		System.out.println("最小数：" + b2.min(b1)); // 求出最小数
		BigInteger result[] = b2.divideAndRemainder(b1); // 求出余数的除法操作
		System.out.println("商是：" + result[0] + "；余数是：" + result[1]);
		System.out.println("等价性是：" + b1.equals(b2));
		int flag = b1.compareTo(b2);
		if (flag == -1)
			System.out.println("比较操作: b1<b2");
		else if (flag == 0)
			System.out.println("比较操作: b1==b2");
		else
			System.out.println("比较操作: b1>b2");

	}
	}

**大浮点数bigdecimal**  
-支持无限大的小数运算  
-注意精度和截断

	import java.math.BigDecimal;
	import java.math.BigInteger;

	public class BigDecimalTest {
	public static void main(String[] args) {
		BigDecimal b1 = new BigDecimal("123456789.987654321"); // 声明BigDecimal对象
		BigDecimal b2 = new BigDecimal("987654321.123456789"); // 声明BigDecimal对象
		System.out.println("b1: " + b1 +  ", b2:" + b2);
		System.out.println("加法操作：" + b2.add(b1)); // 加法操作
		System.out.println("减法操作：" + b2.subtract(b1)); // 减法操作
		System.out.println("乘法操作：" + b2.multiply(b1)); // 乘法操作
		//需要指定位数，防止无限循环，或者包含在try-catch中
		System.out.println("除法操作：" + b2.divide(b1,10,BigDecimal.ROUND_HALF_UP)); // 除法操作
		
		System.out.println("最大数：" + b2.max(b1)); // 求出最大数
		System.out.println("最小数：" + b2.min(b1)); // 求出最小数
		
		int flag = b1.compareTo(b2);
		if (flag == -1)
			System.out.println("比较操作: b1<b2");
		else if (flag == 0)
			System.out.println("比较操作: b1==b2");
		else
			System.out.println("比较操作: b1>b2");
		
		System.out.println("===================");
		
		//尽量采用字符串赋值
		System.out.println(new BigDecimal("2.3"));
		System.out.println(new BigDecimal(2.3));
		
		System.out.println("===================");
		
		BigDecimal num1 = new BigDecimal("10");
		BigDecimal num2 = new BigDecimal("3");
		//需要指定位数，防止无限循环，或者包含在try-catch中
		BigDecimal num3 = num1.divide(num2, 3, BigDecimal.ROUND_HALF_UP);
		System.out.println(num3);
	}仝
	}
####随机数类
**random**  
-nextint()返回一个随机int  
-nextinnt（int a）返回一个【0，a）之间的随机int  
-nextDouble（）返回一个【0.0，1.0】之间的Double  
-ints方法批量返回随机数组  
**Math.random（）返回一个【0.0，1.0】之间的Double

	

	import java.util.Random;

	public class RandomTest {

	public static void main(String[] args) 
	{
		//第一种办法，采用Random类 随机生成在int范围内的随机数
		Random rd = new Random();
		System.out.println(rd.nextInt());
		System.out.println(rd.nextInt(100)); //0--100的随机数
		System.out.println(rd.nextLong());
		System.out.println(rd.nextDouble());		
		System.out.println("=========================");
		
		//第二种，生成一个范围内的随机数 例如0到时10之间的随机数
		//Math.random[0,1)
		System.out.println(Math.round(Math.random()*10));
		System.out.println("=========================");
		
		
		//JDK 8 新增方法
        rd.ints();  //返回无限个int类型范围内的数据
        int[] arr = rd.ints(10).toArray();  //生成10个int范围类的个数。
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
        System.out.println("=========================");
		
        arr = rd.ints(5, 10, 100).toArray();
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
        
        System.out.println("=========================");
        
        arr = rd.ints(10).limit(5).toArray();
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
	}

	}

####数字工具类
**java.lang.Math**  
-绝对值函数abs  
-对数函数log  
-比较函数max，min  
-幂函数pow  
-四舍五入函数round等  
-向下取整floor  
-向上取整ceil  

	
	public class MathTest {

	public static void main(String[] args) {
		
		System.out.println(Math.abs(-5));    //绝对值
		System.out.println(Math.max(-5,-8)); //最大值
		System.out.println(Math.pow(-5,2));  //求幂
		System.out.println(Math.round(3.5)); //四舍五入
		System.out.println(Math.ceil(3.5));  //向上取整
		System.out.println(Math.floor(3.5)); //向下取整
	}

	}
###第三节 字符串相关类
####字符串（1）
**String**  
java中使用频率最高的类  
java是一个不可变量，加减操作性能较差  
以下方法要牢记：charAt，concat，contains，endsWith，equals，equalsIgnoreCase，hashCOde，indexOf，length，matches，replace，replaceAll，split，startsWith，subString，trim，valueOf
	
	
	public class StringTest {

	public static void main(String[] args) {
		String a = "123;456;789;123 ";
		System.out.println(a.charAt(0)); // 返回第0个元素
		System.out.println(a.indexOf(";")); // 返回第一个;的位置
		System.out.println(a.concat(";000")); // 连接一个新字符串并返回，a不变  注意concat函数的返回值只是用来输出，而a的值本身没有变化
		System.out.println(a.contains("000")); // 判断a是否包含000
		System.out.println(a.endsWith("000")); // 判断a是否以000结尾
		System.out.println(a.equals("000")); // 判断是否等于000
		System.out.println(a.equalsIgnoreCase("000"));// 判断在忽略大小写情况下是否等于000
		System.out.println(a.length()); // 返回a长度
		System.out.println(a.trim()); // 返回a去除前后空格后的字符串，a不变 注意不能去掉中间的空格
		String[] b = a.split(";"); // 将a字符串按照;分割成数组
		for (int i = 0; i < b.length; i++) {
			System.out.println(b[i]);
		}

		System.out.println("===================");

		System.out.println(a.substring(2, 5)); // 截取a的第2个到第5个字符 a不变
		System.out.println(a.replace("1", "a"));
		System.out.println(a.replaceAll("1", "a")); // replaceAll第一个参数是正则表达式

		System.out.println("===================");

		String s1 = "12345?6789";
		String s2 = s1.replace("?", "a");
		String s3 = s1.replaceAll("[?]", "a");
		// 这里的[?] 才表示字符问号，这样才能正常替换。不然在正则中会有特殊的意义就会报异常
		System.out.println(s2);
		System.out.println(s3);
		System.out.println(s1.replaceAll("[\\d]", "a")); //将s1内所有数字替换为a并输出，s1的值未改变。

	}
	}
####字符串（2）
**可变字符串**  
-StringBuffer（字符串加减，同步，性能好）  
-StringBuilder（字符串加减，不同步，性能更好）  
**StringBuffer/StringBuilder：方法一样，区别在同步**  
-append/insert/delete/replace/substring  
-length字符串实际大小，capacity字符串占用空间大小  
-trimToSize（）：去除空隙，将字符串存储压缩到实际大小  
-如有大量append，事先预估大小，再调用相应构造函数  

	import java.util.Calendar;

	public class StringAppendTest {

	public static void main(String[] args) {
		int n = 50000;
		Calendar t1 = Calendar.getInstance();
		String a = new String();
		for(int i=0;i<n;i++)
		{
			a = a + i + ",";
		}
		System.out.println(Calendar.getInstance().getTimeInMillis() - t1.getTimeInMillis());
		
		Calendar t2 = Calendar.getInstance();
		StringBuffer b = new StringBuffer();
		for(int i=0;i<n;i++)
		{
			b.append(i);
			b.append(",");
		}
		System.out.println(Calendar.getInstance().getTimeInMillis() - t2.getTimeInMillis());
		
		Calendar t3 = Calendar.getInstance();
		StringBuilder c = new StringBuilder();
		for(int i=0;i<n;i++)
		{
			b.append(i);
			b.append(",");
		}
		System.out.println(Calendar.getInstance().getTimeInMillis() - t3.getTimeInMillis());		
	}
	}
***

	
	public class StringBufferCapacityTest {

	public static void main(String[] args) {
		//StringBuffer的的初始大小为（16+初始字符串长度）即capacity=16+初始字符串长度
		//length 实际长度  capacity 存储空间大小
		StringBuffer sb1 = new StringBuffer();
		System.out.println("sb1 length: " + sb1.length());
		System.out.println("sb1 capacity: " + sb1.capacity());
		System.out.println("=====================");
		
		StringBuffer sb2 = new StringBuffer("123");
		sb2.append("456");
		System.out.println("sb2 length: " + sb2.length());
		System.out.println("sb2 capacity: " + sb2.capacity());
		System.out.println("=====================");
		
		sb2.append("7890123456789");
		System.out.println("sb2 length: " + sb2.length());
		System.out.println("sb2 capacity: " + sb2.capacity());
		System.out.println("=====================");
		
		sb2.append("0");
		System.out.println("sb2 length: " + sb2.length());
		System.out.println("sb2 capacity: " + sb2.capacity());
		//一旦length大于capacity时，capacity便在前一次的基础上加1后翻倍；
		System.out.println("=====================");
		
		//当前sb2length 20   capacity 40， 再append 70个字符 超过(加1再2倍数额)
		sb2.append("1234567890123456789012345678901234567890123456789012345678901234567890");
		System.out.println("sb2 length: " + sb2.length());
		System.out.println("sb2 capacity: " + sb2.capacity());
		//如果append的对象很长，超过(加1再2倍数额)，将以最新的长度更换
		
		System.out.println("=====================");
		sb2.append("0");
		
		System.out.println("sb2 length: " + sb2.length());
		System.out.println("sb2 capacity: " + sb2.capacity());
		sb2.trimToSize();
		System.out.println("=====after trime================");
		System.out.println("sb2 length: " + sb2.length());
		System.out.println("sb2 capacity: " + sb2.capacity());
	}

	}

###第四节 时间相关类
####时间类（1）
**java.util.Date（基本废弃，deprecated）**  
-getTime（），返回至1970.1.1以来的毫秒数  
**java.sql.Date(和数据库对应的时间类)**  

	import java.util.Calendar;
	import java.util.GregorianCalendar;

	public class CalendarClassTest {

	public static void main(String[] args) {
		Calendar gc = Calendar.getInstance();
		System.out.println(gc.getClass().getName());
		//Calendar.getInstance();返回的是GregorianCalendar对象
		
		GregorianCalendar gc2 = new GregorianCalendar();
		System.out.println(gc2.getClass().getName());
	}

	}

####Calendar是目前程序中最常用的，但是是***抽象类***  
-Calendar gc = Calendar.getInstance();  
-Calendar gc = new GregorianCalendar();  
-简单工厂模式  
####时间类（2）
**Calendar**  
-get（Field）来获取时间中每个属性的值；注意，月份0~11  
getTime(),返回相应时间的Date对象  
-getTimeInMills(),返回自1970，1，1以来的毫秒数  
-set（field）设置时间字段  
-add（field，amount）根据指定字段增加/减少时间  
=roll（field，amount）根据指定字段增加/减少时间，但不影响上一级的时间段

	import java.util.Calendar;

	public class CalendarTest {
	
	Calendar calendar = Calendar.getInstance();
	
	public void test1() {
        // 获取年
        int year = calendar.get(Calendar.YEAR);
        // 获取月，这里需要需要月份的范围为0~11，因此获取月份的时候需要+1才是当前月份值
        int month = calendar.get(Calendar.MONTH) + 1;
        // 获取日
        int day = calendar.get(Calendar.DAY_OF_MONTH);

        // 获取时
        int hour = calendar.get(Calendar.HOUR);
        // int hour = calendar.get(Calendar.HOUR_OF_DAY); // 24小时表示
        // 获取分
        int minute = calendar.get(Calendar.MINUTE);
        // 获取秒
        int second = calendar.get(Calendar.SECOND);

        // 星期，英语国家星期从星期日开始计算
        int weekday = calendar.get(Calendar.DAY_OF_WEEK);

        System.out.println("现在是" + year + "年" + month + "月" + day + "日" + hour
                + "时" + minute + "分" + second + "秒" + "星期" + weekday);
    }

    // 一年后的今天
    public void test2() {
        // 同理换成下个月的今天calendar.add(Calendar.MONTH, 1);
        calendar.add(Calendar.YEAR, 1);

        // 获取年
        int year = calendar.get(Calendar.YEAR);
        // 获取月
        int month = calendar.get(Calendar.MONTH) + 1;
        // 获取日
        int day = calendar.get(Calendar.DAY_OF_MONTH);

        System.out.println("一年后的今天：" + year + "年" + month + "月" + day + "日");
    }

    // 获取任意一个月的最后一天
    public void test3() {
        // 假设求6月的最后一天
        int currentMonth = 6;
        // 先求出7月份的第一天，实际中这里6为外部传递进来的currentMonth变量
        // 1
        calendar.set(calendar.get(Calendar.YEAR), currentMonth, 1);

        calendar.add(Calendar.DATE, -1);

        // 获取日
        int day = calendar.get(Calendar.DAY_OF_MONTH);

        System.out.println("6月份的最后一天为" + day + "号");
    }

    // 设置日期
    public void test4() {
        calendar.set(Calendar.YEAR, 2000);
        System.out.println("现在是" + calendar.get(Calendar.YEAR) + "年");

        calendar.set(2018, 7, 8);
        // 获取年
        int year = calendar.get(Calendar.YEAR);
        // 获取月
        int month = calendar.get(Calendar.MONTH)+1;
        // 获取日
        int day = calendar.get(Calendar.DAY_OF_MONTH);

        System.out.println("现在是" + year + "年" + month + "月" + day + "日");
    }
    
    //add和roll的区别//add减后月份也要减，而roll减后月份不减
    public void test5() {     

        calendar.set(2018, 7, 8);
        calendar.add(Calendar.DAY_OF_MONTH, -8);
        
        // 获取年
        int year = calendar.get(Calendar.YEAR);
        // 获取月
        int month = calendar.get(Calendar.MONTH)+1;
        // 获取日
        int day = calendar.get(Calendar.DAY_OF_MONTH);

        System.out.println("2018.8.8, 用add减少8天，现在是" + year + "." + month + "." + day);
        
        calendar.set(2018, 7, 8);
        calendar.roll(Calendar.DAY_OF_MONTH, -8);
        
        // 获取年
        year = calendar.get(Calendar.YEAR);
        // 获取月
        month = calendar.get(Calendar.MONTH)+1;
        // 获取日
        day = calendar.get(Calendar.DAY_OF_MONTH);

        System.out.println("2018.8.8, 用roll减少8天，现在是" + year + "." + month + "." + day);
    }
    
    
	public static void main(String[] args) {
		CalendarTest c = new CalendarTest();
		c.test1();
		System.out.println("============");
		c.test2();
		System.out.println("============");
		c.test3();
		System.out.println("============");
		c.test4();
		System.out.println("============");
		c.test5();

	}

	}
####时间类（3）
**java8推出的新时间api**  
-java.time包  
-旧的设计不好（重名的类，线程不安全等）  
-新版本的优点  
不变性，在多线程环境下  
遵循设计模式，设计更好，可扩展性强大
####时间类（4）  
####java8 时间包概述  
**-java.time包：新的java日期/时间api的基础包**  
-java.time.chrono包：为非iso的日历系统定义了一些泛化的api  
-java.time.formar包：格式化和解析日期时间对象的类  
-java.time.temporal包：包含一些时态对象，可以用其找出关于日期/时间对象的某个特定日期或时间  
-java.time.zone包：包含支持不同时区以及相关规则的类  
时间类（5）
java 8 java.time包主要类  
-Localdate：日期类  
-LocalTime:时间类（时分秒-纳秒）  
-LocalDateTime：LocalDate+LocalTime  
-instant：时间戳

	
	import java.time.LocalDate;
	import java.time.LocalTime;
	import java.time.Period;
	import java.time.temporal.TemporalAdjusters;
 
	public class DateUtil {
 
    public static void main(String[] args) {
 
        LocalDate today = LocalDate.now();
 
        //判断是否是闰年
        System.out.println("Year "+today.getYear()+" is Leap Year  "+today.isLeapYear());
 
        //今天和01/01/2015比较
        System.out.println("Today is before 01/01/2015  "+today.isBefore(LocalDate.of(2015,1,1)));
 
        //当前时分秒
        System.out.println("Current Time="+today.atTime(LocalTime.now()));
 
        //加减时间
        System.out.println("10 days after today will be "+today.plusDays(10));
        System.out.println("3 weeks after today will be "+today.plusWeeks(3));
        System.out.println("20 months after today will be "+today.plusMonths(20));
 
        System.out.println("10 days before today will be "+today.minusDays(10));
        System.out.println("3 weeks before today will be "+today.minusWeeks(3));
        System.out.println("20 months before today will be "+today.minusMonths(20));
 
        //调整时间
        System.out.println("First date of this month= "+today.with(TemporalAdjusters.firstDayOfMonth()));
        LocalDate lastDayOfYear = today.with(TemporalAdjusters.lastDayOfYear());
        System.out.println("Last date of this year= "+lastDayOfYear);
 
        //时间段计算
        Period period = today.until(lastDayOfYear);
        System.out.println("Period Format= "+period);
        System.out.println("Months remaining in the year= "+period.getMonths());        
    }
	}


***

	
	import java.time.Duration;
	import java.time.Instant;
	import java.util.Date;
 
	public class InstantExample {
 
    public static void main(String[] args) {
        //当前时间戳
        Instant timestamp = Instant.now();
        System.out.println("Current Timestamp = "+timestamp);
 
        //从毫秒数来创建时间戳
        Instant specificTime = Instant.ofEpochMilli(timestamp.toEpochMilli());
        System.out.println("Specific Time = "+specificTime);
 
        Date date = Date.from(timestamp); 
        System.out.println("current date = " + date);
    }
 	
	}
***

	import java.time.LocalDate;
	import java.time.Month;
	import java.time.ZoneId;

	public class LocalDateExample {

    public static void main(String[] args) {
 
        //当前时间
        LocalDate today = LocalDate.now();
        System.out.println("Current Date="+today);
 
        //根据指定时间创建LocalDate
        LocalDate firstDay_2014 = LocalDate.of(2014, Month.JANUARY, 1);
        System.out.println("Specific Date="+firstDay_2014);
 
        //给定错误时间参数，将报异常java.time.DateTimeException
        //LocalDate feb29_2014 = LocalDate.of(2014, Month.FEBRUARY, 29);
 
        //可以更改时区
        LocalDate todayBeijing = LocalDate.now(ZoneId.of("Asia/Shanghai"));
        System.out.println("Current Date in Shanghai="+todayBeijing);
 
        //从纪元日01/01/1970开始365天 
        LocalDate dateFromBase = LocalDate.ofEpochDay(365);
        System.out.println("365th day from base date= "+dateFromBase);
 
        //2014年的第100天 
        LocalDate hundredDay2014 = LocalDate.ofYearDay(2014, 100);
        System.out.println("100th day of 2014="+hundredDay2014);
    }
 
	}
***

	
	import java.time.LocalDate;
	import java.time.LocalDateTime;
	import java.time.LocalTime;
	import java.time.Month;
	import java.time.ZoneId;
	import java.time.ZoneOffset;
 
	public class LocalDateTimeExample {
 
    public static void main(String[] args) {
 
        //当前日期 时分秒
        LocalDateTime today = LocalDateTime.now();
        System.out.println("Current DateTime="+today);
 
        //根据日期， 时分秒来创建对象
        today = LocalDateTime.of(LocalDate.now(), LocalTime.now());
        System.out.println("Current DateTime="+today);
 
        //指定具体时间来创建对象
        LocalDateTime specificDate = LocalDateTime.of(2014, Month.JANUARY, 1, 10, 10, 30);
        System.out.println("Specific Date="+specificDate);
 
        //如时间不对，将报异常DateTimeException
        //LocalDateTime feb29_2014 = LocalDateTime.of(2014, Month.FEBRUARY, 28, 25,1,1);
        
        //上海时区
        LocalDateTime todayShanghai = LocalDateTime.now(ZoneId.of("Asia/Shanghai"));
        System.out.println("Current Date in Shanghai="+todayShanghai);
 
         
        //从01/01/1970 10000秒
        LocalDateTime dateFromBase = LocalDateTime.ofEpochSecond(10000, 0, ZoneOffset.UTC);
        System.out.println("10000th second time from 01/01/1970= "+dateFromBase); 
    } 
	}
***

	
	import java.time.LocalTime;
	import java.time.ZoneId;

	public class LocalTimeExample {
 
    public static void main(String[] args) {
 
        //当前时间  时分秒 纳秒
        LocalTime time = LocalTime.now();
        System.out.println("Current Time="+time);
 
        //根据时分秒
        LocalTime specificTime = LocalTime.of(12,20,25,40);
        System.out.println("Specific Time of Day="+specificTime);
 
        //错误的时间参数 将报DateTimeException
        //LocalTime invalidTime = LocalTime.of(25,20);
 
        //上海时间
        LocalTime timeSH = LocalTime.now(ZoneId.of("Asia/Shanghai"));
        System.out.println("Current Time in SH="+timeSH);
 
        
        //一天当中第几秒
        LocalTime specificSecondTime = LocalTime.ofSecondOfDay(10000);
        System.out.println("10000th second time= "+specificSecondTime);
 
    }
 
	}

##第九章 java异常和异常处理
###第一节 java异常分类
####异常概述
####异常：程序不正常的行为或者状态  
-int a = 5/0  
-数组越界访问  例如 int[] a = new int[3] a[3] = 5;//错误//只存在a[0],a[1],a[2]
-读取文件，结果文件不存在
####异常处理
-程序返回到安全状态  
-允许用户保存结果，并以适当的方式关闭程序
####异常分类
####Throwable：所有错误的祖先
####Error：系统内部错误或者资源耗尽。不管
####Exception：程序有关的异常。重点关注
-RuntimeException：程序自身的错误  
5/0，空指针，数组越界...  
-非RuntimeException：外界相关的错误  
打开一个不存在文件  
加载一个不存在的类
####异常分类（3）
####Unchecked Exception：（编译器不会辅助检查的，需要程序员自己管的）异常，包括Error子类和RuntimeException子类
####非RuntimeException的Exception的子类：（编译器会辅助检查的）异常，check Exception
####注意：编译器会检查程序是否为check Exception配置了处理。如果没有处理，会报错
####异常分类（4）
####check Exception（非RUnnableException的Exception的子类），程序员必须处理，以发生后处理为主。编译器会辅助检查
####Unchecked Exception中的RunnableException子类，程序必须处理，以预防为主。编译器不关心此类异常，也不会辅助检查
####Error的子类，可以不用处理
###第二节 java异常处理
####异常处理
#####异常处理
-允许用户及时保存结果  
-抓住异常，分析异常内容  
-控制程序返回到安全状态
####异常处理（2）
#####try-catch-finally：一种保护代码正常运行的机制
#####异常结构
-try....catch(catch可以有多个，下同）  
-try...catch...finally  
-try...finally
#####try必须有，catch和finally至少要有一个

	
	public class TryDemo {

	public static void main(String[] args) {
		try
		{
			int a = 5/2; //无异常
			System.out.println("a is " + a);
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
		}
		finally
		{
			System.out.println("Phrase 1 is over");
		}
		
		try
		{
			int a = 5/0; //ArithmeticException
			System.out.println("a is " + a);
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
		}
		finally
		{
			System.out.println("Phrase 2 is over");
		}
		
		try
		{
			int a = 5/0; //ArithmeticException
			System.out.println("a is " + a);
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
			int a = 5/0; //ArithmeticException
		}
		finally
		{
			System.out.println("Phrase 3 is over");
		}
	}
	}
***
####异常处理（4）  
catch块可以有多个，每个有不同的入口形参。当已发生的异常和某一个catch块中的形参类型一致，那么将执行该catch块中的代码。如果没有一个匹配，catch也不会被触发。最后都进入finally块  
**进入catch块后，并不会返回到try发生异常的位置，也不会执行后续的catch块，一个异常只能进入一个catch块**
####异常处理（5）
catch块的异常匹配是从上到下进行匹配的  
所以一般是将小的异常写在前面，而一些大的（宽泛）的异常写在后面

	
	public class MultipleCatchDemo {

	public static void main(String[] args) {		
		try
		{
			int a = 5/0;
			System.out.println("a is " + a);
		}
		catch(ArithmeticException e)
		{
			e.printStackTrace();
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
		}		
		finally
		{
			System.out.println("Phrase 2 is over");
		}		
	}
	}
***
####异常处理（6）
try结构中，如果有finally块，finally肯定会被执行  
try-catch-finally每个模块里面也会发生异常，所以也可以在内部继续写一个完整的try结构
####异常处理（7）
方法存在可能异常的语句，但不处理，那么可以使用throws来申明异常  
调用带有throws异常（check Exception）的方法，要么处理这些异常，或再次向外throws，直到main方法为止

	public class ThrowsDemo
	{
	public static void main(String [] args)
	{
		try
		{
			int result = new Test().divide( 3, 1 );
			System.out.println("the 1st result is" + result );
		}
		catch(ArithmeticException ex)
		{
			ex.printStackTrace();
		}
		int result = new Test().divide( 3, 0 );
		System.out.println("the 2nd result is" + result );
	}
	}
	class Test
	{
	//ArithmeticException is a RuntimeException, not checked exception
	public int divide(int x, int y) throws ArithmeticException
	{
		int result = x/y;
		return x/y;
	}
	}
***
####异常处理（8）
一个方法被覆盖，覆盖他的方法必须抛出相同的异常，或者异常的子类  
如果父类的方法抛出多个异常，那么重写的子类方法必须抛出那些异常的子类，也就是不能抛出新的异常

	
	public class Father {
	public void f1() throws ArithmeticException
	{
		
	}
	}
	
	public class Son extends Father {
	public void f1() throws IOException
	{
		//子类重写方法，
		//所抛出的异常不能超出父类规定的范围
	}
	}
###第三节 自定义异常
####自定义异常（1）
Exception类是所有异常的父类  
Exception继承自java.lang.Throwable,同时它有一个兄弟Error  
Error是更严重的问题，一般是系统层面的，无需程序处理  
程序只需处理Exception  
####自定义异常（2）
#####自定义异常，需要继承Exception类或其子类。  
-继承自Exception，就变成Checked Exception  
-继承自RuntimeException，就变成Unchecked Exception  
#####自定义的重点在构造函数
-调用父类Exception的message构造函数  
-可以自定义自己的成员变量  
#####在程序中采用throw主动抛出异常

	public class MyException extends Exception {

	private String returnCode ;  //异常对应的返回码
	private String returnMsg;  //异常对应的描述信息
	
	public MyException() {
		super();
	}

	public MyException(String returnMsg) {
		super(returnMsg);
		this.returnMsg = returnMsg;
	}

	public MyException(String returnCode, String returnMsg) {
		super();
		this.returnCode = returnCode;
		this.returnMsg = returnMsg;
	}

	public String getReturnCode() {
		return returnCode;
	}

	public String getreturnMsg() {
		return returnMsg;
	}
	}

***

	public class MyExceptionTest {
	public static void testException() throws MyException {  
       throw new MyException("10001", "The reason of myException");  //在方法内部程序中，抛出异常采用throw关键字，在方法头部申明异常采用throws关键字
         
    }  
	
	public static void main(String[] args) {

		//MyExceptionTest.testException();//没有处理异常
		
		try {
			MyExceptionTest.testException();
		} catch (MyException e) {
			e.printStackTrace();
			System.out.println("returnCode:"+e.getReturnCode());
			System.out.println("returnMsg:"+e.getreturnMsg());
		}
	}
	}

####自定义函数（4）

	
	public class DivideByMinusException extends Exception {
	int divisor;
	public DivideByMinusException(String msg, int divisor)
	{
		super(msg);
		this.divisor = divisor;
	}
	public int getDevisor()
	{
		return this.getDevisor();
	}
	}
***

	
	public class Student {
	
	public int divide(int x, int y) 
	{
		return x/y;
	}
	
	public static void main(String[] args) throws DivideByMinusException{
		Student newton = new Student();
		//newton.divide2(5, 0);
		newton.divide5(5, -2);
	}	
	
	public int divide2(int x, int y)
	{
		int result;
		try
		{
			result = x/y;
			System.out.println("result is " + result);
		}
		catch(ArithmeticException ex)
		{
			System.out.println(ex.getMessage());
			return 0;
		}
		catch(Exception ex)
		{
			ex.printStackTrace();
			return 0;
		}
		return result;
	}
	
	//ArithmeticException is a unchecked exception,编译器可以不管
	public int divide3(int x, int y) throws ArithmeticException
	{		
		return x/y;
	}
	
	public int divide4(int x, int y) 
	{		
	//		try
	//		{
	//			return divide3(x,y);
	//		}
	//		catch(ArithmeticException ex)
	//		{
	//			ex.printStackTrace();
	//			return 0;
	//		}
		return divide3(x,y);  //尽管divide3报告异常，divide4无需处理。因为这个异常是unchecked exception
		//如果调用divide5(x,y);  那么就需要做try。。。catch处理，因为它抛出checked exception
	}
	
	public int divide5(int x, int y) throws DivideByMinusException
	{		
		try
		{
			if(y<0)
			{
				throw new DivideByMinusException("The divisor is negative", y);
			}
			return divide3(x,y);
		}
		catch(ArithmeticException ex)
		{
			ex.printStackTrace();
			return 0;
		}
	}
	}

***
#####总结：
-自定义异常继承自Exception或者RuntimeException  
-自定义异常重点在构造函数  
-采用throw抛出异常

##第十章 java数据结构
###第一节 数组
####数组（1）
#####数组是存放多个数据的容器  
-数据是同一种类型  
-所有数据是线性规则排列  
-可通过位置索引来快速定位访问数据  
-需明确容器的长度

	
	public class ArrayTest {

	public static void main(String[] args) {
		
		int a[]; //a 还没有new操作  实际上是null，也不知道内存位置
		int[] b; //b 还没有new操作  实际上是null，也不知道内存位置
		int[] c = new int[2]; //c有2个元素，都是0
		c[0] = 10; c[1] = 20; //逐个初始化
		
		int d[] = new int[]{0,2,4};//d有3个元素, 0,2,4，同时定义和初始化
		int d1[] = {1,3,5};        //d1有3个元素, 1,3,5 同时定义和初始化
		
		//注意声明变量时候没有分配内存，不需要指定大小，以下是错误示例
		//int e[5];
		//int[5] f;
		//int[5] g = new int[5];
		//int h[5] = new int[5];
		
		//需要自己控制索引位置
		for(int i=0;i<d.length;i++)	{
			System.out.println(d[i]);
		}
		
		//无需控制索引位置
		for(int e : d) {
			System.out.println(e);
		}
	}
	}

####数组（3）
#####数据索引
-数组的lenth属性标识数组的长度  
-从0开始，到lenth-1  
-int[] a = new int[5]; //a[0]~a[4],not a[5]; a.lenth是5  
-数组不能越界访问，否则会报错
####数组（4）
#####数组遍历：两种方法

	//需要自己控制索引位置
		for(int i=0;i<d.length;i++)	{
			System.out.println(d[i]);
		}
		
		//无需控制索引位置，写法是最右侧是数组，左侧int一个数据
		//第二种for语句是for-each语句，不会出现越界访问，更好！
		for(int e : d) {
			System.out.println(e);
		}

####数组（5）
#####多维数组
-数组的数组  
-存储是按照行存储原则

	
	public class MultiDimArrayTest {

	public static void main(String[] args) {
		//Java多维数组是按照行存储		
		
		//规则数组
		int a[][] = new int[2][3];
		//不规则数组 
		int b[][];
		b = new int[3][];
		b[0]=new int[3];
		b[1]=new int[4];
		b[2]=new int[5];
		
		int k = 0;
		for(int i=0;i<a.length;i++)
		{
			for(int j=0;j<a[i].length;j++)
			{
				a[i][j] = ++k; 
			}
		}
		
		for(int[] items : a)
		{
			for(int item : items)
			{
				System.out.print(item + ", ");
			}
			System.out.println();
		}
	}
	}
###第二节 JCF
####JCF（1）
#####容器：能够存放数据的空间结构
-数组/多维数组，只能线性存放  
-列表/散列集/树/.....   
#####容器框架：为表示和操作容器而规定的一种标准体系结构
-对外的接口：容器中能存放的抽象数据类型  
-接口的实现：可复用的数据结构  
-算法：对数据的查找和排序  
#####容器框架的优点：提高数据存取效率，避免程序员重复劳动  
#####C++的STL，java的JCF
####JCF(5)
#####JCF主要的数据结构实现类
-列表（List，ArrayList，LinkedList）  
-集合（Set，HashSet，TreeSet，LinkedHashSet）  
-映射（Map，HashMap，TreeMap，LinkedHashMap）
#####JCF主要的算法类
-arrays：对数组进行查找和排序等操作  
-Collections：对	Collection及其子类进行排序和查找操作  
###第三节 列表List
####List（1）
#####List：列表
-有序的Collection  
-允许重复的元素  
-{1,2,4{5,2},1,3}
#####List主要实现  
-ArrayList（非同步的）  
-LinkedList（非同步）  
-Vector（同步）
####List（2）
#####ArrayList：
-以数组实现的列表，不支持同步  
-利用索引位置可以快速定位访问  
-不适合指定位置的插入，删除操作  
-适合变动不大，主要用于查询的数据  
-和java数组相比，其容量是动态可调整的 //在java中，数组是静态的，数组长度一旦确定就不能更改，而ArrayList是动态的，容器（长度）可以随时调整  
-ArrayList在元素填满容器时会自动扩充容器大小的50% 

	import java.util.ArrayList;
	import java.util.Iterator;
	//Vector 几乎和ArrayList一样，除了Vector本身是同步的

	public class ArrayListTest {
	public static void main(String[] a) {  
	    ArrayList<Integer> al = new ArrayList<Integer>();  //ArrayList<Integer> al，是泛型的表示，意思是al这个数组结构里面只能容纳Integer的对象，其他对象无法放入
	    al.add(3);  
	    al.add(2);          
	    al.add(1);  //ArrayList只能装对象，当add（1）时，会自动将普通int变量3自动装箱为Integer（1）的对象，然后放入ArrayList容器中
	    al.add(4);  
	    al.add(5);  
	    al.add(6);  
	    al.add(new Integer(6));  
	  
	    System.out.print("The third element is  ");
	    System.out.println(al.get(3));
	    al.remove(3);  //删除第四个元素，后面元素往前挪动
	    al.add(3, 9);  //将9插入到第4个元素，后面元素往后挪动
	    
	    System.out.println("======遍历方法=============");
	    
	    ArrayList<Integer> as = new ArrayList<Integer>(100000);
	    for (int i=0; i<100000; i++)
	    {
	    	as.add(i);
	    }
	    traverseByIterator(as);//第一种lterator遍历
	    traverseByIndex(as);//索引位置遍历
	    traverseByFor(as);    //for-each遍历	
	}  
	public static void traverseByIterator(ArrayList<Integer> al)
	{
		long startTime = System.nanoTime();
		System.out.println("============迭代器遍历=============="); 
	    Iterator<Integer> iter1 = al.iterator();  
	    while(iter1.hasNext()){  
	        iter1.next();  
	    }
		long endTime = System.nanoTime();
	    long duration = endTime - startTime;
	    System.out.println(duration + "纳秒");
	}
	public static void traverseByIndex(ArrayList<Integer> al)
	{
		long startTime = System.nanoTime();
		System.out.println("============随机索引值遍历=============="); 
	    for(int i=0;i<al.size();i++)
	    {
	    	al.get(i);
	    }
		long endTime = System.nanoTime();
	    long duration = endTime - startTime;
	    System.out.println(duration + "纳秒");
	}
	public static void traverseByFor(ArrayList<Integer> al)
	{
		long startTime = System.nanoTime();
		System.out.println("============for循环遍历=============="); 
	    for(Integer item : al)
	    {
	    	;
	    }
		long endTime = System.nanoTime();
	    long duration = endTime - startTime;
	    System.out.println(duration + "纳秒");
	}
	}

####List（3）
#####LInkLIst：
-以双向链表实现的列表，不支持同步  
-可被当做堆栈，队列和双端队列进行操作  
-顺序访问高效，随机访问较差，中间插入和删除高效  
-适用于经常变化的数据   

	import java.util.ArrayList;
	import java.util.Iterator;
	import java.util.LinkedList;

	public class LinkedListTest {

	public static void main(String[] args) {
		LinkedList<Integer> ll = new LinkedList<Integer>();  
	    ll.add(3);  
	    ll.add(2);  
	    ll.add(5);  
	    ll.add(6);  
	    ll.add(6);  
	    System.out.println(ll.size());
	    ll.addFirst(9);  //在头部增加9
	    ll.add(3, 10);   //将10插入到第四个元素，四以及后续的元素往后挪动
	    ll.remove(3);    //将第四个元素删除
	    
	    LinkedList<Integer> list = new LinkedList<Integer>();
	    for (int i=0; i<100000; i++)
	    {
	    	list.add(i);
	    }
	    traverseByIterator(list);
	    traverseByIndex(list);
	    traverseByFor(list);    

	}
	
	public static void traverseByIterator(LinkedList<Integer> list)
	{
		long startTime = System.nanoTime();
		System.out.println("============迭代器遍历=============="); 
	    Iterator<Integer> iter1 = list.iterator();  
	    while(iter1.hasNext()){  
	        iter1.next();  
	    }
		long endTime = System.nanoTime();
	    long duration = endTime - startTime;
	    System.out.println(duration + "纳秒");
	}
	public static void traverseByIndex(LinkedList<Integer> list)
	{
		long startTime = System.nanoTime();
		System.out.println("============随机索引值遍历=============="); 
	    for(int i=0;i<list.size();i++)
	    {
	    	list.get(i);
	    }
		long endTime = System.nanoTime();
	    long duration = endTime - startTime;
	    System.out.println(duration + "纳秒");
	}
	public static void traverseByFor(LinkedList<Integer> list)
	{
		long startTime = System.nanoTime();
		System.out.println("============for循环遍历=============="); 
	    for(Integer item : list)
	    {
	    	;
	    }
		long endTime = System.nanoTime();
	    long duration = endTime - startTime;
	    System.out.println(duration + "纳秒");
	}
	}
***

	import java.util.ArrayList;
	import java.util.LinkedList;

	public class ListCompareTest {

	public static void main(String[] args) {
		int times = 10 * 1000;
	    // times = 100 * 1000;
	    // times = 1000 * 1000;
	    
		ArrayList<Integer> arrayList = new ArrayList<Integer>();
	    LinkedList<Integer> linkedList = new LinkedList<Integer>();

	    System.out.println("Test times = " + times);
	    System.out.println("-------------------------");
	    
	    // ArrayList add
	    long startTime = System.nanoTime();

	    for (int i = 0; i < times; i++) {
	        arrayList.add(0,i);
	    }
	    long endTime = System.nanoTime();
	    long duration = endTime - startTime;
	    System.out.println(duration + " <--ArrayList add");

	    // LinkedList add
	    startTime = System.nanoTime();

	    for (int i = 0; i < times; i++) {
	        linkedList.add(0,i);
	    }
	    endTime = System.nanoTime();
	    duration = endTime - startTime;
	    System.out.println(duration + " <--LinkedList add");
	    System.out.println("-------------------------");
	    
	    // ArrayList get
	    startTime = System.nanoTime();

	    for (int i = 0; i < times; i++) {
	        arrayList.get(i);
	    }
	    endTime = System.nanoTime();
	    duration = endTime - startTime;
	    System.out.println(duration + " <--ArrayList get");

	    // LinkedList get
	    startTime = System.nanoTime();

	    for (int i = 0; i < times; i++) {
	        linkedList.get(i);
	    }
	    endTime = System.nanoTime();
	    duration = endTime - startTime;
	    System.out.println(duration + " <--LinkedList get");
	    System.out.println("-------------------------");

	    // ArrayList remove
	    startTime = System.nanoTime();

	    for (int i = 0; i < times; i++) {
	        arrayList.remove(0);
	    }
	    endTime = System.nanoTime();
	    duration = endTime - startTime;
	    System.out.println(duration + " <--ArrayList remove");

	    // LinkedList remove
	    startTime = System.nanoTime();

	    for (int i = 0; i < times; i++) {
	        linkedList.remove(0);
	    }
	    endTime = System.nanoTime();
	    duration = endTime - startTime;
	    System.out.println(duration + " <--LinkedList remove");
	}
	}

####List（4）
#####Vector（同步）
-和ArrayList类似，可变数组实现的列表  
-Vector同步，适合在多线程下使用  
-原先不属于JCF框架，属于java最早的数据结构，性能较差  
-从JDK1.2开始，Vector被重写，并纳入到JCF  
-官方文档建议在非同步情况下，优先采用ArrayList  

	import java.util.ArrayList;
	import java.util.Enumeration;
	import java.util.Iterator;
	import java.util.Vector;

	public class VectorTest {

	public static void main(String[] args) {
		Vector<Integer> v = new Vector<Integer>();
		v.add(1);
		v.add(2);
		v.add(3);
		v.remove(2);
		v.add(1, 5);
		System.out.println(v.size());

		System.out.println("======遍历方法=============");

		Vector<Integer> v2 = new Vector<Integer>(100000);
		for (int i = 0; i < 100000; i++) {
			v2.add(i);
		}
		traverseByIterator(v2);	//第一种lterator遍历
		traverseByIndex(v2);	//索引位置遍历
		traverseByFor(v2);	//for-each遍历
		traverseByEnumeration(v2);	//Enumeration遍历
	}

	public static void traverseByIterator(Vector<Integer> v) {
		long startTime = System.nanoTime();
		System.out.println("============迭代器遍历==============");
		Iterator<Integer> iter1 = v.iterator();
		while (iter1.hasNext()) {
			iter1.next();
		}
		long endTime = System.nanoTime();
		long duration = endTime - startTime;
		System.out.println(duration + "纳秒");
	}

	public static void traverseByIndex(Vector<Integer> v) {
		long startTime = System.nanoTime();
		System.out.println("============随机索引值遍历==============");
		for (int i = 0; i < v.size(); i++) {
			v.get(i);
		}
		long endTime = System.nanoTime();
		long duration = endTime - startTime;
		System.out.println(duration + "纳秒");
	}

	public static void traverseByFor(Vector<Integer> v) {
		long startTime = System.nanoTime();
		System.out.println("============for循环遍历==============");
		for (Integer item : v) {
			;
		}
		long endTime = System.nanoTime();
		long duration = endTime - startTime;
		System.out.println(duration + "纳秒");
	}

	public static void traverseByEnumeration(Vector<Integer> v) {
		long startTime = System.nanoTime();
		System.out.println("============Enumeration遍历==============");
		for (Enumeration<Integer> enu = v.elements(); enu.hasMoreElements();) {
			enu.nextElement();
		}
		long endTime = System.nanoTime();
		long duration = endTime - startTime;
		System.out.println(duration + "纳秒");
	}
	}
###第四节 集合
####集合（1）
#####集合Set
-确定性：对任意对象都能判定其是否属于某一个集合  
-互异性：集合内每个元素都是不相同的，**注意是内容互异**  
-无序性：集合内的顺序无关
####集合（2）
#####java中的集合接口Set
-HashSet（基于散列函数的集合，无序，不支持同步）  
-TreeSet（基于树结构的集合，可排序的，不支持同步）  
-LinkedHashSet（基于散列函数和双向链表的集合，可排序的，不支持同步）
####集合（3）
#####HashSet
-基于HashMap实现的，可以容纳null元素，不支持同步  
**Set s = Collections.sychronizedSet(new HashSet(...));**  
-add 添加一个元素  
-clear 清除整个HashSet  
-contains 判定是否包含一个元素  
-remove 删除一个元素 size 大小  
-retainAll 计算两个集合交集

	import java.util.ArrayList;
	import java.util.HashSet;
	import java.util.Iterator;

	public class HashSetTest {	
	public static void main(String[] args) {
		HashSet<Integer> hs = new HashSet<Integer>();
		hs.add(null);
		hs.add(1000);
		hs.add(20);
		hs.add(3);
		hs.add(40000);
		hs.add(5000000);
		hs.add(3);                      //3 重复
		hs.add(null);                   //null重复
		System.out.println(hs.size());  //6
		if(!hs.contains(6))
		{
			hs.add(6);
		}
		System.out.println(hs.size());  //7
		hs.remove(4);
		System.out.println(hs.size());  //6
		//hs.clear();
		//System.out.println(hs.size());  //0
		
		System.out.println("============for循环遍历=============="); 
	    for(Integer item : hs)
	    {
	    	System.out.println(item);
	    }
	    
	    System.out.println("============测试集合交集==============");
	    
	    HashSet<String> set1 = new HashSet<String>();
	    HashSet<String> set2 = new HashSet<String>();

        set1.add("a");
        set1.add("b");
        set1.add("c");

        set2.add("c");
        set2.add("d");
        set2.add("e");

        //交集
        set1.retainAll(set2);
        System.out.println("交集是 "+set1);
        
        System.out.println("============测试多种遍历方法速度==============");
		
		HashSet<Integer> hs2 = new HashSet<Integer>();
		for(int i=0;i<100000;i++)	{
			hs2.add(i);
		}
		traverseByIterator(hs2);
		traverseByFor(hs2);		
	}
	
	public static void traverseByIterator(HashSet<Integer> hs)
	{
		long startTime = System.nanoTime();
		System.out.println("============迭代器遍历=============="); 
	    Iterator<Integer> iter1 = hs.iterator();  
	    while(iter1.hasNext()){  
	        iter1.next();  
	    }
		long endTime = System.nanoTime();
	    long duration = endTime - startTime;
	    System.out.println(duration + "纳秒");
	}
	public static void traverseByFor(HashSet<Integer> hs)
	{
		long startTime = System.nanoTime();
		System.out.println("============for循环遍历=============="); 
	    for(Integer item : hs)
	    {
	    	;
	    }
		long endTime = System.nanoTime();
	    long duration = endTime - startTime;
	    System.out.println(duration + "纳秒");
	}
	}
####集合（4）
#####LinkedHashSet
-继承HashSet，也是基于HashMap实现的，可以容纳null元素  
-不支持同步  
**Set s = Collections.sychronizedSet(new LinkedHashSet(...));**  
-方法和HashSet基本一致  
**add，clear，contains，remove，size**  
-通过一个双向链表维护插入序列，意思就是说顺序是保留的

	import java.util.ArrayList;
	import java.util.HashSet;
	import java.util.Iterator;
	import java.util.LinkedHashSet;

	public class LinkedHashSetTest {
	public static void main(String[] args) {
		LinkedHashSet<Integer> lhs = new LinkedHashSet<Integer>();
		lhs.add(null);
		lhs.add(1000);
		lhs.add(20);
		lhs.add(3);
		lhs.add(40000);
		lhs.add(5000000);
		lhs.add(3);                      //3 重复
		lhs.add(null);                   //null 重复
		System.out.println(lhs.size());  //6
		if(!lhs.contains(6))
		{
			lhs.add(6);
		}
		System.out.println(lhs.size());  //7
		lhs.remove(4);
		System.out.println(lhs.size());  //6
		//lhs.clear();
		//System.out.println(lhs.size());  //0
		
		System.out.println("============for循环遍历=============="); 
	    for(Integer item : lhs)
	    {
	    	System.out.println(item);
	    }
		
		LinkedHashSet<Integer> lhs2 = new LinkedHashSet<Integer>();
		for(int i=0;i<100000;i++)
		{
			lhs2.add(i);
		}
		traverseByIterator(lhs2);
		traverseByFor(lhs2);
		
	}
	
	public static void traverseByIterator(LinkedHashSet<Integer> hs)
	{
		long startTime = System.nanoTime();
		System.out.println("============迭代器遍历=============="); 
	    Iterator<Integer> iter1 = hs.iterator();  
	    while(iter1.hasNext()){  
	        iter1.next();  
	    }
		long endTime = System.nanoTime();
	    long duration = endTime - startTime;
	    System.out.println(duration + "纳秒");
	}
	public static void traverseByFor(LinkedHashSet<Integer> hs)
	{
		long startTime = System.nanoTime();
		System.out.println("============for循环遍历=============="); 
	    for(Integer item : hs)
	    {
	    	;
	    }
		long endTime = System.nanoTime();
	    long duration = endTime - startTime;
	    System.out.println(duration + "纳秒");
	}
	}
  
####集合（5）
#####TreeSet
-基于TreeMap实现的，**不可容纳null元素**，不支持同步  
**SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));**  
-add 添加一个元素  
-clear 清除整个TreeSet  
-contains 判定是否包含一个元素  
-remove 删除一个元素 size 大小  
-根据compareTo方法或指定Comparartor排序，就是从小到大，或者从大到小 

		import java.util.ArrayList;
	import java.util.HashSet;
	import java.util.Iterator;
	import java.util.LinkedHashSet;
	import java.util.TreeSet;
	
	public class TreeSetTest {
		public static void main(String[] args) {
			TreeSet<Integer> ts = new TreeSet<Integer>();
			// ts.add(null);  错误，不支持null
			ts.add(1000);
			ts.add(20);
			ts.add(3);
			ts.add(40000);
			ts.add(5000000);
			ts.add(3);                      //3 重复
			System.out.println(ts.size());  //5
			if(!ts.contains(6))
			{
				ts.add(6);
			}
			System.out.println(ts.size());  //6
			ts.remove(4);
			System.out.println(ts.size());  //5
			//lhs.clear();
			//System.out.println(lhs.size());  //0
			
			System.out.println("============for循环遍历=============="); 
		    for(Integer item : ts)
		    {
		    	System.out.println(item);
		    }
		    
			TreeSet<Integer> ts2 = new TreeSet<Integer>();
			for(int i=0;i<100000;i++)
			{
				ts2.add(i);
			}
			traverseByIterator(ts2);
			traverseByFor(ts2);
			
		}
		
		public static void traverseByIterator(TreeSet<Integer> hs)
		{
			long startTime = System.nanoTime();
			System.out.println("============迭代器遍历=============="); 
		    Iterator<Integer> iter1 = hs.iterator();  
		    while(iter1.hasNext()){  
		        iter1.next();  
		    }
			long endTime = System.nanoTime();
		    long duration = endTime - startTime;
		    System.out.println(duration + "纳秒");
		}
		public static void traverseByFor(TreeSet<Integer> hs)
		{
			long startTime = System.nanoTime();
			System.out.println("============for循环遍历=============="); 
		    for(Integer item : hs)
		    {
		    	;
		    }
			long endTime = System.nanoTime();
		    long duration = endTime - startTime;
		    System.out.println(duration + "纳秒");
		}
	
	}

####集合（6）
#####HashSet，LinkedHashSet，TreeSet的元素都只能是对象
#####HashSet和LinkedSet判定元素重复的原则  
-判定两个元素的HashCode返回值是否相同，若不同，返回false  
-若两者HashCode相同，判定equals方法，若不同，则返回false；否在返回true  
-HashCode和equals方法是所有类都有的，因为类Object有
#####TreeSet判定元素重复的原则
-**需要元素继承自Comparable接口**  
-比较两个元素的compareTO方法

Cat类本身没有HashCode（），而是继承于object类的，而object的HashCode会返回对象的信息和内存地址经过运算后的一个int值，两个不同的Cat（4）对象，他们的hashcode是不同的  
Dog类本身改写了HashCode方法，其返回值是具体的size，所以两个不同的Dog（4），他们的hashcode返回值是相同的

		
	public class Tiger implements Comparable{//tiger实现comparable接口，所以必须实现compareto方法来比较大小 compareto方法具体规则如下：int a = obj1.compareTo(obj2);  如果a>0,则obj1》obj2；如果a==0；则obj1==obj2；如果a<0,则obj1<obj2
		private int size;
		 
	    public Tiger(int s) {
	        size = s;    
	    }    
	    
	    public int getSize() {
			return size;
		}
	    
		public int compareTo(Object o) {
	    	System.out.println("Tiger compareTo()~~~~~~~~~~~");
	        return size - ((Tiger) o).getSize();
	    }
	}
***

		
	class Cat
	{
		private int size;
		
		public Cat(int size)
		{
			this.size = size;
		}
	}
***

		
	class Dog {
	    private int size;
	 
	    public Dog(int s) {
	        size = s;
	    }      
	    public int getSize() {
			return size;
		}
	
		public boolean equals(Object obj2)   {//equals方法，hashcode方法，tostring方法是三位一体的，改了其中一个就要改其他两个，不能让一个返回True，其他两个返回false
	    	System.out.println("Dog equals()~~~~~~~~~~~");
	    	if(0==size - ((Dog) obj2).getSize()) {
	    		return true;
	    	} else {
	    		return false;
	    	}
	    }
	    
	    public int hashCode() {
	    	System.out.println("Dog hashCode()~~~~~~~~~~~");
	    	return size;
	    }
	    
	    public String toString() {
	    	System.out.print("Dog toString()~~~~~~~~~~~");
	        return size + "";
	    }
	}
***

		import java.util.HashSet;
	
	
	public class HashSetJudgeRuleTest {
	
		public static void main(String[] args) {
			HashSet<Cat> hs = new HashSet<Cat>();
			hs.add(new Cat(1));
			hs.add(new Cat(2));
			hs.add(new Cat(3));
			hs.add(new Cat(3));
			System.out.println(hs.size()); //4
		}
	}
***

		import java.util.HashSet;
	import java.util.Iterator;
	import java.util.LinkedHashSet;
	import java.util.TreeSet;
	
	
	public class ObjectHashSetTest {
	
		public static void main(String[] args) {
			System.out.println("==========Cat HashSet ==============");
			HashSet<Cat> hs = new HashSet<Cat>();  
			hs.add(new Cat(2));  
			hs.add(new Cat(1));  
			hs.add(new Cat(3));  
			hs.add(new Cat(5));  
			hs.add(new Cat(4)); 
			hs.add(new Cat(4)); 
			System.out.println(hs.size());  //6
			
			System.out.println("========================");
			LinkedHashSet<Cat> lhs= new LinkedHashSet<Cat>();  
			lhs.add(new Cat(2));  
			lhs.add(new Cat(1));  
			lhs.add(new Cat(3));  
			lhs.add(new Cat(5));  
			lhs.add(new Cat(4));  
			lhs.add(new Cat(4));		
			System.out.println(lhs.size());  //6
			
			
			
			System.out.println("==========Dog HashSet ==============");
			HashSet<Dog> hs2 = new HashSet<Dog>();  
			hs2.add(new Dog(2));  
			hs2.add(new Dog(1));  
			hs2.add(new Dog(3));  
			hs2.add(new Dog(5));  
			hs2.add(new Dog(4)); 
			hs2.add(new Dog(4)); //Hashset的元素判定只和hashcode，equals这两个方法有关，和compareto方法无关
			System.out.println(hs2.size());  //5
			
			System.out.println("========================");
			LinkedHashSet<Dog> lhs2= new LinkedHashSet<Dog>();  
			lhs2.add(new Dog(2));  
			lhs2.add(new Dog(1));  
			lhs2.add(new Dog(3));  
			lhs2.add(new Dog(5));  
			lhs2.add(new Dog(4));  
			lhs2.add(new Dog(4)); 		
			System.out.println(lhs2.size());  //5
			
	
			System.out.println("==========Tiger HashSet ==============");		
			HashSet<Tiger> hs3 = new HashSet<Tiger>();  
			hs3.add(new Tiger(2));  
			hs3.add(new Tiger(1));  
			hs3.add(new Tiger(3));  
			hs3.add(new Tiger(5));  
			hs3.add(new Tiger(4)); 
			hs3.add(new Tiger(4)); 
			System.out.println(hs3.size());  //6
			
			System.out.println("========================");
			LinkedHashSet<Tiger> lhs3= new LinkedHashSet<Tiger>();  
			lhs3.add(new Tiger(2));  
			lhs3.add(new Tiger(1));  
			lhs3.add(new Tiger(3));  
			lhs3.add(new Tiger(5));  
			lhs3.add(new Tiger(4));  
			lhs3.add(new Tiger(4)); 		
			System.out.println(lhs3.size());  //6
		}
	}

###第五节 映射Map
####映射（1）
#####Map映射
-数学定义：两个集合之间的元素对应关系  
-一个输入对应到一个输出  
-｛1，张三｝，｛2，李四｝，｛Key，value｝，键值对，KV对  
#####java中的Map
-Hashtable（同步，慢，数据量小）  
-HashMap（不支持同步，快，数据量大）  
-properties（同步，文件形式，数据量小）
####映射（2）
#####Hashtable
-Kv对，K和V都不允许为null  
-同步，多线程安全  
-无序的  
-适合小数据量  
-主要方法：clear，contains/containsValue，containsKey，get，put，remove，size


|clear|清空数据|
|:---:|:---:|
|contains|等同于containsValue|
|containsKey|是否包含某一个key|
|containsValue|是否包含某一个值|
|get|根据key获取相应的值|
|put|增加一个新的kv对|
|remove|删除一个kv对|
|size|返回数据大小|

		import java.util.Enumeration;
	import java.util.Hashtable;
	import java.util.Iterator;
	import java.util.Map;
	import java.util.Map.Entry;
	
	public class HashtableTest {
	
		public static void main(String[] args) {
			Hashtable<Integer,String> ht =new  Hashtable<Integer,String>();
			//ht.put(1, null); 编译不报错  运行报错
			//ht.put(null,1);  编译报错
			ht.put(1000, "aaa");
			ht.put(2, "bbb");
			ht.put(30000, "ccc");
			System.out.println(ht.contains("aaa"));
			System.out.println(ht.containsValue("aaa"));
			System.out.println(ht.containsKey(30000));
			System.out.println(ht.get(30000));
			
			ht.put(30000, "ddd");  //更新覆盖ccc
			System.out.println(ht.get(30000));
			
			ht.remove(2);
			System.out.println("size: " + ht.size());
			
			ht.clear();
			System.out.println("size: " + ht.size());
			
			
			Hashtable<Integer,String> ht2 =new  Hashtable<Integer,String>();
			for(int i=0;i<100000;i++)
			{
				ht2.put(i, "aaa");
			}
			traverseByEntry(ht2);
			traverseByKeySet(ht2);
			traverseByKeyEnumeration(ht2);		
		}
		
		public static void traverseByEntry(Hashtable<Integer,String> ht)
		{
			long startTime = System.nanoTime();
			System.out.println("============Entry迭代器遍历==============");
			Integer key;
			String value;
			Iterator<Entry<Integer, String>> iter = ht.entrySet().iterator();
			while(iter.hasNext()) {
			    Map.Entry<Integer, String> entry = iter.next();
			    // 获取key
			    key = entry.getKey();
			    // 获取value
			    value = entry.getValue();
			    //System.out.println("Key:" + key + ", Value:" + value);
			}
			long endTime = System.nanoTime();
		    long duration = endTime - startTime;
		    System.out.println(duration + "纳秒");
		}
		
		
		public static void traverseByKeySet(Hashtable<Integer,String> ht)
		{
			long startTime = System.nanoTime();
			System.out.println("============KeySet迭代器遍历=============="); 
			Integer key;
			String value;
			Iterator<Integer> iter = ht.keySet().iterator();
			while(iter.hasNext()) {
			    key = iter.next();		    
			    // 获取value
			    value = ht.get(key);
			    //System.out.println("Key:" + key + ", Value:" + value);
			}
			long endTime = System.nanoTime();
		    long duration = endTime - startTime;
		    System.out.println(duration + "纳秒");
		}
		
		
		public static void traverseByKeyEnumeration(Hashtable<Integer,String> ht)
		{
			long startTime = System.nanoTime();
			System.out.println("============KeyEnumeration迭代器遍历=============="); //只读的，比较快
			Integer key;
			String value;
			Enumeration<Integer> keys = ht.keys();
			while(keys.hasMoreElements()) {
			    key = keys.nextElement();   
			    // 获取value
			    value = ht.get(key);
			    //System.out.println("Key:" + key + ", Value:" + value);
			}
			long endTime = System.nanoTime();
		    long duration = endTime - startTime;
		    System.out.println(duration + "纳秒");
		}
	}
####映射（3）
#####HashMap
-kv对，k和v都允许为null  
-不同步，多线程不安全  
**Map m = Collections.synchronizedMap(new HashMap(...));**  
-无序的  
-主要方法：clear，containsValue，containsKey，get，put，remove，size

		import java.util.Enumeration;
	import java.util.HashMap;
	import java.util.Iterator;
	import java.util.Map;
	import java.util.Map.Entry;
	
	public class HashMapTest {
	
		public static void main(String[] args) {
			HashMap<Integer,String> hm =new  HashMap<Integer,String>();
			hm.put(1, null); 
			hm.put(null, "abc");  
			hm.put(1000, "aaa");
			hm.put(2, "bbb");
			hm.put(30000, "ccc");
			System.out.println(hm.containsValue("aaa"));
			System.out.println(hm.containsKey(30000));
			System.out.println(hm.get(30000));
			
			hm.put(30000, "ddd");  //更新覆盖ccc
			System.out.println(hm.get(30000));
			
			hm.remove(2);
			System.out.println("size: " + hm.size());
			
			hm.clear();
			System.out.println("size: " + hm.size());
			
			
			HashMap<Integer,String> hm2 =new  HashMap<Integer,String>();
			for(int i=0;i<100000;i++)
			{
				hm2.put(i, "aaa");
			}
			traverseByEntry(hm2);
			traverseByKeySet(hm2);		
		}
		
		public static void traverseByEntry(HashMap<Integer,String> ht)
		{
			long startTime = System.nanoTime();
			System.out.println("============Entry迭代器遍历==============");
			Integer key;
			String value;
			Iterator<Entry<Integer, String>> iter = ht.entrySet().iterator();
			while(iter.hasNext()) {
			    Map.Entry<Integer, String> entry = iter.next();
			    // 获取key
			    key = entry.getKey();
			    // 获取value
			    value = entry.getValue();
			    //System.out.println("Key:" + key + ", Value:" + value);
			}
			long endTime = System.nanoTime();
		    long duration = endTime - startTime;
		    System.out.println(duration + "纳秒");
		}
		
		
		public static void traverseByKeySet(HashMap<Integer,String> ht)
		{
			long startTime = System.nanoTime();
			System.out.println("============KeySet迭代器遍历=============="); 
			Integer key;
			String value;
			Iterator<Integer> iter = ht.keySet().iterator();
			while(iter.hasNext()) {
			    key = iter.next();		    
			    // 获取value
			    value = ht.get(key);
			    //System.out.println("Key:" + key + ", Value:" + value);
			}
			long endTime = System.nanoTime();
		    long duration = endTime - startTime;
		    System.out.println(duration + "纳秒");
		}
	}
####映射（4）
#####LinkedHashMap
-基于双向链表的维持插入顺序的HashMap
#####TreeMap
-基于红黑树的Map，可以根据key的自然排序或者compareTo方法进行排序输出  
HashMap遍历是无序的  
LinkedHashMap遍历是和插入顺序一样的  
TreeMap遍历顺序是按照大小或者CompareTO方法规定的

		import java.util.LinkedHashMap;
	import java.util.Iterator;
	import java.util.Map;
	import java.util.Map.Entry;
	
	public class LinkedHashMapTest {
	
		public static void main(String[] args) {
			LinkedHashMap<Integer,String> hm =new  LinkedHashMap<Integer,String>();
			hm.put(1, null); 
			hm.put(null, "abc");  
			hm.put(1000, "aaa");
			hm.put(2, "bbb");
			hm.put(30000, "ccc");
			System.out.println(hm.containsValue("aaa"));
			System.out.println(hm.containsKey(30000));
			System.out.println(hm.get(30000));
			
			hm.put(30000, "ddd");  //更新覆盖ccc
			System.out.println(hm.get(30000));
			
			hm.remove(2);
			System.out.println("size: " + hm.size());
			
			//hm.clear();
			//System.out.println("size: " + hm.size());
			
			System.out.println("遍历开始==================");
			
			Integer key;
			String value;
			Iterator<Entry<Integer, String>> iter = hm.entrySet().iterator();
			while(iter.hasNext()) {
			    Map.Entry<Integer, String> entry = iter.next();
			    // 获取key
			    key = entry.getKey();
			    // 获取value
			    value = entry.getValue();
			    System.out.println("Key:" + key + ", Value:" + value);
			}
			System.out.println("遍历结束==================");		
			
			LinkedHashMap<Integer,String> hm2 =new  LinkedHashMap<Integer,String>();
			for(int i=0;i<100000;i++)
			{
				hm2.put(i, "aaa");
			}
			traverseByEntry(hm2);
			traverseByKeySet(hm2);		
		}
		
		public static void traverseByEntry(LinkedHashMap<Integer,String> ht)
		{
			long startTime = System.nanoTime();
			System.out.println("============Entry迭代器遍历==============");
			Integer key;
			String value;
			Iterator<Entry<Integer, String>> iter = ht.entrySet().iterator();
			while(iter.hasNext()) {
			    Map.Entry<Integer, String> entry = iter.next();
			    // 获取key
			    key = entry.getKey();
			    // 获取value
			    value = entry.getValue();
			    //System.out.println("Key:" + key + ", Value:" + value);
			}
			long endTime = System.nanoTime();
		    long duration = endTime - startTime;
		    System.out.println(duration + "纳秒");
		}
		
		
		public static void traverseByKeySet(LinkedHashMap<Integer,String> ht)
		{
			long startTime = System.nanoTime();
			System.out.println("============KeySet迭代器遍历=============="); 
			Integer key;
			String value;
			Iterator<Integer> iter = ht.keySet().iterator();
			while(iter.hasNext()) {
			    key = iter.next();		    
			    // 获取value
			    value = ht.get(key);
			    //System.out.println("Key:" + key + ", Value:" + value);
			}
			long endTime = System.nanoTime();
		    long duration = endTime - startTime;
		    System.out.println(duration + "纳秒");
		}
	}
####映射（5）
#####Properties
-继承于Hashtable  
-可以将kv对保存在文件中  
-适用于数据量小的配置文件  
-继承自Hashtable方法  
-从文件加载的load方法，写入到文件中的store方法  
-获取属性的getProperty，设置属性setproperty  

		import java.io.BufferedInputStream;
	import java.io.File;
	import java.io.FileInputStream;
	import java.io.FileOutputStream;
	import java.io.IOException;
	import java.io.InputStream;
	import java.io.OutputStream;
	import java.util.Enumeration;
	import java.util.Properties;
	
	//关于Properties类常用的操作
	public class PropertiesTest {
	    //根据Key读取Value
	    public static String GetValueByKey(String filePath, String key) {
	        Properties pps = new Properties();
	        try {
	            InputStream in = new BufferedInputStream (new FileInputStream(filePath));  
	            pps.load(in); //所有的K-V对都加载了
	            String value = pps.getProperty(key);
	            //System.out.println(key + " = " + value);
	            return value;
	            
	        }catch (IOException e) {
	            e.printStackTrace();
	            return null;
	        }
	    }
	    
	    //读取Properties的全部信息
	    public static void GetAllProperties(String filePath) throws IOException {
	        Properties pps = new Properties();
	        InputStream in = new BufferedInputStream(new FileInputStream(filePath));
	        pps.load(in); //所有的K-V对都加载了 load是加载原文件所有kv对，store是将所有kv对写入到文件中，getproperty是获取某一个key所对应的value，setproperty是写入一个kv对
	        Enumeration en = pps.propertyNames(); //得到配置文件的名字
	        
	        while(en.hasMoreElements()) {
	            String strKey = (String) en.nextElement();
	            String strValue = pps.getProperty(strKey);
	            //System.out.println(strKey + "=" + strValue);
	        }
	        
	    }
	    
	    //写入Properties信息
	    public static void WriteProperties (String filePath, String pKey, String pValue) throws IOException {
	        File file = new File(filePath);
	    	if(!file.exists())
	    	{
	    		file.createNewFile();
	    	}
	    	Properties pps = new Properties();
	        
	        InputStream in = new FileInputStream(filePath);
	        //从输入流中读取属性列表（键和元素对） 
	        pps.load(in);
	        //调用 Hashtable 的方法 put。使用 getProperty 方法提供并行性。  
	        //强制要求为属性的键和值使用字符串。返回值是 Hashtable 调用 put 的结果。
	        OutputStream out = new FileOutputStream(filePath);
	        pps.setProperty(pKey, pValue);
	        //以适合使用 load 方法加载到 Properties 表中的格式，  
	        //将此 Properties 表中的属性列表（键和元素对）写入输出流  
	        pps.store(out, "Update " + pKey + " name");
	        out.close();
	    }
	    
	    public static void main(String [] args) throws IOException{
	    	System.out.println("写入Test.properties================");
	        WriteProperties("Test.properties","name", "12345");
	        
	        System.out.println("加载Test.properties================");
	        GetAllProperties("Test.properties");
	        
	        System.out.println("从Test.properties加载================");
	        String value = GetValueByKey("Test.properties", "name");
	        System.out.println("name is " + value);
	    }
	}
###第六节 工具类
####JCF的工具类
#####JCF中工具类
-不存储数据，而是在数据容器上，实现高效操作  
**排序**  
**搜索**  
-Arrays类 
-Collections类
####Arrays
#####Arrays：处理对象是数组
-排序：对数组排序，sort/paralleSort  
-查找：从数组中查找一个元素，binarySearch  
-批量拷贝：从源数组批量复制元素到目标数组，CopyOf  
-批量赋值：对数组进行批量赋值，fill  
-等价性比较：判定两个数组内容是否相同，equals 

		import java.util.Arrays;
	import java.util.Random;
	
	public class ArraysTest { 
		public static void main(String[] args) {
			testSort();//sort排序
			testSearch();//binarySearch，二分法查找
			testCopy();//copyOf批量复制
			testFill();//批量赋值
			testEquality();//等价性比较
		}
		public static void testSort() {
			Random r = new Random();
			int[] a = new int[10];
			for(int i=0;i<a.length;i++)	{
				a[i] = r.nextInt();
			}
			System.out.println("===============测试排序================");
			System.out.println("排序前");
			for(int i=0;i<a.length;i++)	{
				System.out.print(a[i] + ",");
			}
			System.out.println();
			System.out.println("排序后");
			Arrays.sort(a);
			for(int i=0;i<a.length;i++)	{
				System.out.print(a[i] + ",");
			}
			System.out.println();		
		}
	
		public static void testSearch() {
			Random r = new Random();
			int[] a = new int[10];
			for(int i=0;i<a.length;i++)
			{
				a[i] = r.nextInt();
			}
			a[a.length-1] = 10000;
			System.out.println("===========测试查找============");
			System.out.println("10000 的位置是" + Arrays.binarySearch(a, 10000));
		}
		
		public static void testCopy() {
			Random r = new Random();
			int[] a = new int[10];
			for(int i=0;i<a.length;i++)
			{
				a[i] = r.nextInt();
			}
			int[] b = Arrays.copyOf(a, 5);
			System.out.println("===========测试拷贝前五个元素============");
			System.out.print("源数组：");
			for(int i=0;i<a.length;i++)
			{
				System.out.print(a[i] + ",");
			}
			System.out.println();
			System.out.print("目标数组：");
			for(int i=0;i<b.length;i++)
			{
				System.out.print(b[i] + ",");
			}
			System.out.println();
		}
		public static void testFill() {
			int[] a = new int[10];
			Arrays.fill(a, 100);
			Arrays.fill(a, 2, 8, 200);
			System.out.println("===========测试批量赋值============");
			System.out.print("数组赋值后：");
			for(int i=0;i<a.length;i++)
			{
				System.out.print(a[i] + ",");
			}
			System.out.println();
		}
		public static void testEquality() {
			int[] a = new int[10];
			Arrays.fill(a, 100);
			int[] b = new int[10];
			Arrays.fill(b, 100);		
			System.out.println(Arrays.equals(a, b));
			b[9] = 200;
			System.out.println(Arrays.equals(a, b));
		}
	}
####包装器类
#####Collections：处理对象是Collection及其子类  
-排序：对List进行排序，sort  
-搜索：从List中搜索元素，binarySearch  
-批量赋值：对List批量赋值，fill  
-最大，最小：查找集合中最大/最小值，max，min  
-反序：将list反序排列，reverse

		import java.util.ArrayList;
	import java.util.Collections;
	
	public class CollectionsTest {
	
		public static void main(String[] args) {
			ArrayList<Integer> list = new ArrayList<Integer>();
	        list.add(1);
	        list.add(12);
	        list.add(2);
	        list.add(19);
	         
	        // 排序
	        Collections.sort(list);
	        // 检索
	        System.out.println("元素所在的索引值是：" + Collections.binarySearch(list, 12));
	        //最大最小
	        System.out.println("最大值：" + Collections.max(list));
	        System.out.println("最小值：" + Collections.min(list));
	        Collections.reverse(list); //翻转不需要用到排序
	         
	        Collections.fill(list, 100); //全部赋值为100
		}
	}
####对象比较
#####对象实现Comparable接口（需要修改对象类）
-compareTo方法  
    >返回1，==返回0，<返回-1  
-Arrays和Collections在进行对象sort时，会自动调用该方法  
#####新建Comparator（适用于对象类不可更改的情况）
-Compare方法  
	>返回1，==返回0，<返回-1  
-Comparator比较器将作为参数提交给工具类的sort方法

		import java.util.Arrays;
	
	public class Person implements Comparable<Person> {
		String name;
		int age;
	
		public String getName() {
			return name;
		}
	
		public int getAge() {
			return age;
		}
	
		public Person(String name, int age) {
			this.name = name;
			this.age = age;
		}
	
		public int compareTo(Person another) {
			int i = 0;
			i = name.compareTo(another.name); // 使用字符串的比较
			if (i == 0) {
				// 如果名字一样,比较年龄, 返回比较年龄结果
				return age - another.age;
			} else {
				return i; // 名字不一样, 返回比较名字的结果.
			}
		}
	
		public static void main(String... a) {
			Person[] ps = new Person[3];
			ps[0] = new Person("Tom", 20);
			ps[1] = new Person("Mike", 18);
			ps[2] = new Person("Mike", 20);
	
			Arrays.sort(ps);
			for (Person p : ps) {
				System.out.println(p.getName() + "," + p.getAge());
			}
		}
	}
***

		import java.util.Arrays;
	import java.util.Comparator;
	
	public class Person2Comparator  implements Comparator<Person2> {
		public int compare(Person2 one, Person2 another) {
			int i = 0;
			i = one.getName().compareTo(another.getName());
			if (i == 0) {
				// 如果名字一样,比较年龄,返回比较年龄结果
				return one.getAge() - another.getAge();
			} else {
				return i; // 名字不一样, 返回比较名字的结果.
			}
		}
	
		public static void main(String[] args) {
			// TODO Auto-generated method stub
			Person2[] ps = new Person2[3];
			ps[0] = new Person2("Tom", 20);
			ps[1] = new Person2("Mike", 18);
			ps[2] = new Person2("Mike", 20);
	
			Arrays.sort(ps, new Person2Comparator());
			for (Person2 p : ps) {
				System.out.println(p.getName() + "," + p.getAge());
			}
		}
	}
***

		
	public class Person2 {
		private String name;
	    private int age;
		public String getName() {
			return name;
		}
		public int getAge() {
			return age;
		}
	
	    public Person2(String name, int age)
	    {
	    	this.name = name;
	    	this.age = age;
	    }
	}
##第十一章 java文件读写
###第一节 文件系统及java基本操作
####文件概述
文件系统是由OS（操作系统）管理的  
文件系统和java进程是**平行**的，是两套系统  
文件系统是由文件夹和文件递归组合而成的  
文件目录分隔符  
-Linux/Unix用/隔开  
-Windows用\隔开，涉及到转义，在程序中需用/或\\代替  
文件包括文件里面的内容和文件基本属性  
文件基本属性：名称,大小，扩展名，修改时间
####java文件类File
java.io.File是文件和目录的重要类（JDK6及其以前是唯一）  
-目录也使用File类进行表示  
File类于OS无关，但会受到OS的权限限制  
常用方法  
-createNewFile，delete，exists，getAbsolutePath，getName，getParent，getPath，isDirectory，isFile，lenth，listFiles，mkdir，mkdirs  
注意：FIle不涉及到具体的文件内容，只涉及属性

		
	import java.io.*;
	public class FileAttributeTest{
	  public static void main(String[] args){
		//创建目录
		File d=new File("c:/temp");//java用File对象作为文件或者目录的句柄（代理人）。操作File对象，就是操作文件或者目录
		if(!d.exists())//exists判断File对象是否存在；mkdir创建一级（一层）目录；mkdirs创建多级（多层）目录；isDirectory是否是目录；isFile是否是文件；createNewFIle创建新文件（非目录）
		{//getName获取文件名字；getParent获取上一层目录路径；getPath获取文件全路径；lenth获取文件大小；lastModified返回文件最后一次修改日期
			d.mkdirs();  //mkdir 创建单级目录  mkdirs 连续创建多级目录
		}
		System.out.println("Is d directory? " + d.isDirectory());
		
		//创建文件  
	    File f=new File("C:/temp/abc.txt");    
	    if(!f.exists())
	    {    	
	      try
	      {
	        f.createNewFile(); //创建abc.txt
	      }
	      catch(IOException e){ //可能会因为权限不足或磁盘已满报错
	    	  e.printStackTrace();
	      }
	    }  
	    
	    //输出文件相关属性
	    System.out.println("Is f file? " + f.isFile());
	    System.out.println("Name: "+f.getName());
	    System.out.println("Parent: "+f.getParent());
	    System.out.println("Path: "+f.getPath());
	    System.out.println("Size: "+f.length()+" bytes");
	    System.out.println("Last modified time: "+f.lastModified()+"ms");
	    
	    //遍历d目录下所有的文件信息
	    System.out.println("list files in d directory");
	    File[] fs = d.listFiles();  //listFiles列出d目录下所有的子文件，不包括子目录下的文件
	    for(File f1:fs)
	    {
	    	System.out.println(f1.getPath());
	    }
	    
	    //f.delete(); //删除此文件
	    //d.delete(); //删除目录
	  }
	}

###JAVA NIO
####java 7提出的NIO包，提出新的文件系统类
-Path，Files，DirectoryStream,FileVisitor,FileSystem  
-是java.io.File的有益补充  
**文件的复制和移动**  
**文件相对路径**  
**递归遍历目录**  
**递归删除目录**  
	
			
		import java.io.*;
		public class FileAttributeTest{
		  public static void main(String[] args){
			//创建目录
			File d=new File("c:/temp");//java用File对象作为文件或者目录的句柄（代理人）。操作File对象，就是操作文件或者目录
			if(!d.exists())//exists判断File对象是否存在；mkdir创建一级（一层）目录；mkdirs创建多级（多层）目录；isDirectory是否是目录；isFile是否是文件；createNewFIle创建新文件（非目录）
			{//getName获取文件名字；getParent获取上一层目录路径；getPath获取文件全路径；lenth获取文件大小；lastModified返回文件最后一次修改日期
				d.mkdirs();  //mkdir 创建单级目录  mkdirs 连续创建多级目录
			}
			System.out.println("Is d directory? " + d.isDirectory());
			
			//创建文件  
		    File f=new File("C:/temp/abc.txt");    
		    if(!f.exists())
		    {    	
		      try
		      {
		        f.createNewFile(); //创建abc.txt
		      }
		      catch(IOException e){ //可能会因为权限不足或磁盘已满报错
		    	  e.printStackTrace();
		      }
		    }  
		    
		    //输出文件相关属性
		    System.out.println("Is f file? " + f.isFile());
		    System.out.println("Name: "+f.getName());
		    System.out.println("Parent: "+f.getParent());
		    System.out.println("Path: "+f.getPath());
		    System.out.println("Size: "+f.length()+" bytes");
		    System.out.println("Last modified time: "+f.lastModified()+"ms");
		    
		    //遍历d目录下所有的文件信息
		    System.out.println("list files in d directory");
		    File[] fs = d.listFiles();  //listFiles列出d目录下所有的子文件，不包括子目录下的文件
		    for(File f1:fs)
		    {
		    	System.out.println(f1.getPath());
		    }
		    
		    //f.delete(); //删除此文件
		    //d.delete(); //删除目录
		  }
		}
***

		import java.io.File;
	import java.nio.file.FileSystems;
	import java.nio.file.Files;
	import java.nio.file.Path;
	import java.nio.file.Paths;
	
	public class PathTest {
		public static void main(String[] args) {
			// Path 和 java.io.File 基本类似
			// 获得path方法一,c:/temp/abc.txt
			Path path = FileSystems.getDefault().getPath("c:/temp", "abc.txt");
			System.out.println(path.getNameCount());
	
			// 获得path方法二，用File的toPath()方法获得Path对象
			File file = new File("c:/temp/abc.txt");
			Path pathOther = file.toPath();
			// 0,说明这两个path是相等的
			System.out.println(path.compareTo(pathOther));
	
			// 获得path方法三
			Path path3 = Paths.get("c:/temp", "abc.txt");
			System.out.println(path3.toString());
	
			// 合并两个path
			Path path4 = Paths.get("c:/temp");
			System.out.println("path4: " + path4.resolve("abc.txt"));
	
			if (Files.isReadable(path)) {
				System.out.println("it is readable");
			} else {
				System.out.println("it is not readable");
			}
		}
	}
***

		import java.io.IOException;
	import java.nio.file.DirectoryStream;
	import java.nio.file.Files;
	import java.nio.file.LinkOption;
	import java.nio.file.Path;
	import java.nio.file.Paths;
	import java.nio.file.StandardCopyOption;
	import java.nio.file.attribute.BasicFileAttributes;
	import java.util.Date;
	
	public class FilesTest {
		
		public static void main(String[] a)
		{
			moveFile();
			fileAttributes();
			createDirectory();
		}
	
		public static void moveFile() {
			Path from = Paths.get("c:/temp", "abc.txt");
			//移动c:/temp/abc.txt到c:/temp/test/def.txt，如目标文件已存在，就替换
			Path to = from.getParent().resolve("test/def.txt");
			try {
				//文件的大小bytes
				System.out.println(Files.size(from));
				//调用文件移动方法  如果目标文件已经存在，就替换
				Files.move(from, to, StandardCopyOption.REPLACE_EXISTING);
			} catch (IOException e) {
				System.err.println("移动文件错误" + e.getMessage());
			}
		}
		
		
		public static void fileAttributes(){
			Path path = Paths.get("c:/temp");
			//1
			System.out.println(Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS));
			//2
			try {
				//获得文件的基础属性
				BasicFileAttributes attributes = Files.readAttributes(path, BasicFileAttributes.class);
				System.out.println(attributes.isDirectory());//File.isDirectory 判断是否是目录；BasicFileAttributes.isDirectory判断是否是目录；BasicFileAttributes.creationTime返回创建时间；BasicFileAttributes.lastModifiedTime返回最后修改时间
				System.out.println(new Date(attributes.lastModifiedTime().toMillis()).toLocaleString());
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		
		public static void createDirectory(){//Files.notExists 测试此路径所在的文件是否不存在；File.createDirectories首先创建所有不存在的父目录来创建目录；File.createFile创建一个新的和空的文件；Files.newDirectoryStream打开一个目录，返回一个DirectoryStream以遍历目录中的条目；
			Path path = Paths.get("c:/temp/test");
			try {
				//创建文件夹
				if(Files.notExists(path)){
					Files.createDirectories(path);
					System.out.println("create dir");
				}else{
					System.out.println("dir exists");
				}
				Path path2 = path.resolve("A.java"); 
				Path path3 = path.resolve("B.java");
				Path path4 = path.resolve("C.txt");
				Path path5 = path.resolve("D.jpg");
				Files.createFile(path2);
				Files.createFile(path3);
				Files.createFile(path4);
				Files.createFile(path5);
				
				//不加条件遍历
				DirectoryStream<Path> paths = Files.newDirectoryStream(path);
				for(Path p : paths){
					System.out.println(p.getFileName());
				}
				System.out.println();
				
				//创建一个带有过滤器,过滤文件名以java txt结尾的文件
				DirectoryStream<Path> pathsFilter = Files.newDirectoryStream(path, "*.{java,txt}");
				for(Path p : pathsFilter){
					System.out.println(p.getFileName());
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
***

		import java.io.IOException;
	import java.nio.file.FileSystems;
	import java.nio.file.FileVisitOption;
	import java.nio.file.FileVisitResult;
	import java.nio.file.FileVisitor;
	import java.nio.file.Files;
	import java.nio.file.Path;
	import java.nio.file.PathMatcher;
	import java.nio.file.Paths;
	import java.nio.file.attribute.BasicFileAttributes;
	import java.util.EnumSet;
	
	class Search implements FileVisitor {
	
		private final PathMatcher matcher;
	
		public Search(String ext) {
			matcher = FileSystems.getDefault().getPathMatcher("glob:" + ext);
		}
	
		public void judgeFile(Path file) throws IOException {
			Path name = file.getFileName();
			if (name != null && matcher.matches(name)) {
				//文件名字已经匹配
				System.out.println("Searched file was found: " + name + " in " + file.toRealPath().toString());
			}
		}
	
		@Override
		public FileVisitResult postVisitDirectory(Object dir, IOException exc) throws IOException {
			System.out.println("Visited: " + (Path) dir);
			return FileVisitResult.CONTINUE;
		}
	
		@Override
		public FileVisitResult preVisitDirectory(Object dir, BasicFileAttributes attrs) throws IOException {
			return FileVisitResult.CONTINUE;
		}
	
		@Override
		public FileVisitResult visitFile(Object file, BasicFileAttributes attrs) throws IOException {
			judgeFile((Path) file);
			return FileVisitResult.CONTINUE;
		}
	
		@Override
		public FileVisitResult visitFileFailed(Object file, IOException exc) throws IOException {
			// report an error if necessary
			return FileVisitResult.CONTINUE;
		}
	}
	//查找某一个目录下所有的jpg文件，包括子文件夹
	public class SearchJPGFiles {
	
		public static void main(String[] args) throws IOException {
			//定义扩展名，和待查找目录
			String ext = "*.jpg";
			Path fileTree = Paths.get("C:/temp/");
			Search walk = new Search(ext);
			EnumSet<FileVisitOption> opts = EnumSet.of(FileVisitOption.FOLLOW_LINKS);
	
			Files.walkFileTree(fileTree, opts, Integer.MAX_VALUE, walk);
	
		}
	}
	//FileVistor接口的实现，被提供给Files.walkFileTree方法来访问文件树种的每个文件；FileVisitor主要有以下4个方法：preVisitDirectory访问一个目录前调用；postVisitDirectory访问一个目录后调用；visitFile访问文件时调用；visitFileFailed访问文件失败后调用
###第二节 java io包概述
**javaio包**
文件系统和java系统是两套系统  
java读写文件，只能以（数据）流的形式进行读写  
java.io包中  
-节点类：直接对文件进行读写  
-包装类：（转化类：字节/字符/数据类型的转化类  装饰类：装饰节点类）  
**javaio包（2）**
字节：byte，8bit，最基础的存储单位  
字符：a，10000，我  
数据类型：3，5.25，abcdef  
文件是以字节保存的，因此程序将变量保存到文件需要转化  
**javaio包（3）**  
节点类：直接操作文件类  
-inputStream，outputStream（字节）  
Fileinputstream,FileOutputStream  
-Reader,Writer（字符）  
Filereader，FileWrite
**javaio包（4）**
转换类：字符到字节之间的转化  
-inputStreamReader：文件读取时字节，转化为java能理解的字符  
-outputStreamWriter：java将字符转化为字节输入到文件中  
>装饰类：装饰节点类  
>DateinputStream，DateOutputStream：封装数据流  
>BufferedInputStream，BufferOutputStream：缓存字节流  
>BUfferedreader，BufferedWriter：缓存字符流

###第三节 文本
**文本文件读写**
>文件类型  
>一般文本文件（若干行字符构成的文件），如txt等  
>一般二进制文件，如数据文件dat  
>带有特殊格式的文本文件，如xml等  
>带特殊格式的二进制文件，如doc，ppt等  

文件是数据的一个容器（口袋）  
文件可以存放大量的数据  
文件很大，注定java只能以流形式依次处理
**文本文件读写（3）**
>写文件  
>先创建文件，写入文件，关闭文件  
>FileOutputStream（向文件写字节），OutputStreamWrite（字节和字符转化），BufferedWrite（写缓冲区类，加速写操作）  
>BufferWrite  
>Write（写）  
>newline（换行）  
>try-resource语句，自动关闭资源  
>关闭最外层的数据流，将自动把其上所有的数据流关闭  

		import java.io.BufferedReader;
	import java.io.FileInputStream;
	import java.io.InputStreamReader;
	import java.util.HashMap;
	
	public class TxtFileRead {
		public static void main(String[] args) {
			readFile1();
			System.out.println("===================");
			//readFile2(); //JDK 7及以上才可以使用
		}
	
		public static void readFile1() {
			FileInputStream fis = null;
			InputStreamReader isr = null;
			BufferedReader br = null;
			try {
				fis = new FileInputStream("c:/temp/abc.txt"); // 节点类
				isr = new InputStreamReader(fis, "UTF-8"); // 转化类
				//isr = new InputStreamReader(fis);
				br = new BufferedReader(isr); // 装饰类
				// br = new BufferedReader(new InputStreamReader(new
				// FileInputStream("c:/temp/abc.txt")))
				String line;
				while ((line = br.readLine()) != null) // 每次读取一行
				{
					System.out.println(line);
				}
			} catch (Exception ex) {
				ex.printStackTrace();
			} finally {
				try {
					br.close(); // 关闭最后一个类，会将所有的底层流都关闭
				} catch (Exception ex) {
					ex.printStackTrace();
				}
			}
		}
	
		public static void readFile2() {
			String line;
			//try-resource 语句，自动关闭资源
			try (BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream("c:/temp/abc.txt")))) {
				while ((line = in.readLine()) != null) {
					System.out.println(line);
				}
			}
			catch(Exception ex)
			{
				ex.printStackTrace();
			}
		}
	}


**文本文件读写（4）**
>读文件  
>先打开文件，一行一行读入数据，关闭文件  
>FileInputStream，InputStreamWrite，BufferedReader  
>BufferReader  
>readline（一次读一行数据）  
>try-resource语句，自动关闭资源  
>关闭最外层资源，将会把其上所有的数据流关闭  

		import java.io.*;
	
	public class TxtFileWrite {
		public static void main(String[] args) {
			//writeFile1();
			System.out.println("===================");
			//writeFile2(); // JDK 7及以上才可以使用
		}
	
		public static void writeFile1() {
			FileOutputStream fos = null;//字节类，负责写字节
			OutputStreamWriter osw = null;//转化类，负责字符到字节的转换
			BufferedWriter bw = null;//装饰类，负责字节写入到缓存区
			//三者构建关系：BufferedWrite(OutputSteamWrite(FileOutputStream))
			try {
				fos = new FileOutputStream("c:/temp/abc.txt"); // 节点类
				osw = new OutputStreamWriter(fos, "UTF-8"); // 转化类
				//osw = new OutputStreamWriter(fos); // 转化类
				bw = new BufferedWriter(osw); // 装饰类
				// br = new BufferedWriter(new OutputStreamWriter(new
				// FileOutputStream("c:/temp/abc.txt")))
				bw.write("我们是");
				bw.newLine();
				bw.write("Ecnuers.^^");
				bw.newLine();
			} catch (Exception ex) {
				ex.printStackTrace();
			} finally {
				try {
					bw.close(); // 关闭最后一个类，会将所有的底层流都关闭
				} catch (Exception ex) {
					ex.printStackTrace();
				}
			}
		}
	
		public static void writeFile2() {
			//try-resource 语句，自动关闭资源
			try (BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("c:/temp/abc.txt")))) {
				bw.write("我们是");
				bw.newLine();
				bw.write("Ecnuers.^^");
				bw.newLine();
			} catch (Exception ex) {
				ex.printStackTrace();
			}
		}
	
	}

###第四节 二进制文件读写
**二进制文件读写（1）**
>二进制文件  
>狭义上来说，采用字节编码，非字符编码的文件  
>广义上来说，一切文件都是二进制文件  
>用记事本无法打开/阅读

>二进制文件读写  
>输出数据到文件中  
>从文件中读取数据
**二进制文件读写（2）**  
>写文件  
>先创建文件，写入数据，关闭文件  
>FIleOutputStream，BufferedOutputStream，DateOutputStream  
>DateOutputStream  
>flush（刷新缓存）  
>write/writeBoolean/writeByte/WriteChars/WriteDouble/WriteInt/WriteUTF/...  
>try-resource语句，自动关闭资源  
>关闭最外层数据流，会把其他所有数据流关闭  

		
	import java.io.*;
	public class BinFileWrite{
	  public static void main(String[] args) throws Exception{
		writeFile();
	    System.out.println("done.");
	  }
	  
	  public static void writeFile() {
		  FileOutputStream fos = null;//FileoutputStream 节点类，负责写字节 BufferedOutputStream 装饰类，负责写字节数据到缓冲区
		  DataOutputStream dos = null;//DateOutputStreamWrite 转化类，负责数据类型到字节转化
		  BufferedOutputStream bos = null;//三者构建关系：DateOutputStreamWrite（BufferedOutputStream（FileOutputStream））
			try {
				fos = new FileOutputStream("c:/temp/def.dat"); // 节点类
				bos = new BufferedOutputStream(fos); // 装饰类
				dos = new DataOutputStream(bos); // 装饰类		
				
				dos.writeUTF("a");
				dos.writeInt(20);
				dos.writeInt(180);
				dos.writeUTF("b");
			} catch (Exception ex) {
				ex.printStackTrace();
			} finally {
				try {
					dos.close(); // 关闭最后一个类，会将所有的底层流都关闭
				} catch (Exception ex) {
					ex.printStackTrace();
				}
			}
		}
	}
***
**二进制文件读写（3）**
>读文件  
>先打开文件，读取数据，关闭文件  
>FIleInputStream，BufferedInputStream，DataInputStream  
>DataInputStream  
>read/readBoolean/readChar/readDouble/readFloat/readInt/readUTF/...  
>try-resource语句，自动关闭资源  
>关闭最外层数据流，将会把其上所有的数据流关闭  

		
	import java.io.*;
	public class BinFileRead{
	  public static void main(String[] args) throws Exception{
		  readFile();
	  }
	  public static void readFile() {
			//try-resource 语句，自动关闭资源
			try (DataInputStream dis = new DataInputStream(new BufferedInputStream(new FileInputStream("c:/temp/def.dat")))) {
				String a, b;
			    int c, d;
			    a=dis.readUTF();//FileInputStream字节类，负责读写字节；BufferedInputStream装饰类，负责将读的字节数据到缓冲区；
			    c=dis.readInt();//DateInputStreamWrite 转化类，负责将字节到数据类型转化
			    d=dis.readInt();//三者关系DataInputStreamWrite（BufferedInputStream（FileInputStream））
			    b=dis.readUTF();
			    System.out.println("a: "+a);
			    System.out.println("c: "+c);
			    System.out.println("d: "+d);
			    System.out.println("b: "+b);
			}
			catch(Exception ex)
			{
				ex.printStackTrace();
			}
		}
	}
###第五节 ZIP文件读写
**java zip包**
>压缩包：zip，rar，gz......  
>java.zip包支持zip和Gzip包的压缩和解压  
>zip文件操作类：java.util.zip包中  
>>java.io.InputStream,java.io.OutputStream的子类  
>ZipInputStream,ZIPOutPutStream 压缩文件输入输出流  
>ZIpEntry 压缩项
***
**压缩**
>单个/多个压缩  
>打开输出zip文件 
>添加一个zipEntry，一个zipEntry代表一个压缩文件，不是代表一个压缩包！   
>打开一个输入文件，读数据，向zipEntry写入数据，关闭输入文件  
>重复以上两个步骤，写入多个文件到zip文件中  
>关闭zip文件  
***
**解压**
>单个/多个解压
>打开输入的zip文件  
>获取下一个zipEntry  
>新建一个目标文件，从zipentry读取数据，向目标文件写入数据，关闭目标文件  
>重复以上两种步骤，从zip包中读取数据到多个目标文件  
>关闭zip文件
***

		import java.io.File ;  
	import java.io.OutputStream ;  
	import java.io.InputStream ;  
	import java.util.zip.ZipEntry ;  
	import java.util.zip.ZipFile ;  
	import java.util.zip.ZipInputStream ;  
	import java.io.FileInputStream ;  
	import java.io.FileOutputStream ;  
	public class MultipleFileUnzip{  
	    public static void main(String args[]) throws Exception{    
	    	//待解压的zip文件，需要在zip文件上构建输入流，读取数据到Java中
	        File file = new File("c:/temp/multiple.zip") ;   // 定义压缩文件名称  
	        File outFile = null ;   // 输出文件的时候要有文件夹的操作  
	        ZipFile zipFile = new ZipFile(file) ;   // 实例化ZipFile对象  
	        ZipInputStream zipInput = null ;    // 定义压缩输入流  
	        
	        //定义解压的文件名
	        OutputStream out = null ;   // 定义输出流，用于输出每一个实体内容  
	        InputStream input = null ;  // 定义输入流，读取每一个ZipEntry  
	        ZipEntry entry = null ; // 每一个压缩实体  
	        zipInput = new ZipInputStream(new FileInputStream(file)) ;  // 实例化ZIpInputStream 
	        
	        //遍历压缩包中的文件
	        while((entry = zipInput.getNextEntry())!=null){ // 得到一个压缩实体  
	        	System.out.println("解压缩" + entry.getName() + "文件") ;  
	            outFile = new File("c:/temp/" + entry.getName()) ;   // 定义输出的文件路径  
	            if(!outFile.getParentFile().exists()){  // 如果输出文件夹不存在 
	                outFile.getParentFile().mkdirs() ;   
	                // 创建文件夹 ,如果这里的有多级文件夹不存在,请使用mkdirs()
	                // 如果只是单纯的一级文件夹,使用mkdir()就好了
	            }  
	            if(!outFile.exists()){  // 判断输出文件是否存在
	            	if(entry.isDirectory())
	            	{
	            		outFile.mkdirs();
	            		System.out.println("create directory...");
	            	}
	            	else
	            	{
	            		outFile.createNewFile() ;   // 创建文件
	            		System.out.println("create file...");
	            	}                  
	            }  
	            if(!entry.isDirectory())
	            {
	            	input = zipFile.getInputStream(entry) ; // 得到每一个实体的输入流  
	                out = new FileOutputStream(outFile) ;   // 实例化文件输出流  
	                int temp = 0 ;  
	                while((temp=input.read())!=-1){  
	                    out.write(temp) ;  
	                }  
	                input.close() ;     // 关闭输入流  
	                out.close() ;   // 关闭输出流  
	            }
	            
	        }  
	        input.close() ;  
	    }  
	}
***
		//文件夹压缩
	import java.io.File ;
	import java.io.FileInputStream ;
	import java.io.InputStream ;
	import java.util.zip.ZipEntry ;
	import java.util.zip.ZipOutputStream ;
	import java.io.FileOutputStream ;
	public class MultipleFileZip{
		public static void main(String args[]) throws Exception{	// 所有异常抛出
			File file = new File("c:/temp/multiple") ;	// 定义要压缩的文件夹
			File zipFile = new File("c:/temp/multiple2.zip") ;	// 定义压缩文件名称
			
			InputStream input = null ;	// 定义文件输入流
			ZipOutputStream zipOut = null ;	// 声明压缩流对象
			zipOut = new ZipOutputStream(new FileOutputStream(zipFile)) ;
			zipOut.setComment("multiple file zip") ;	// 设置注释
			
			//开始压缩
			int temp = 0 ;
			if(file.isDirectory()){	// 判断是否是文件夹
				File lists[] = file.listFiles() ;	// 列出全部子文件
				for(int i=0;i<lists.length;i++){
					input = new FileInputStream(lists[i]) ;	// 定义文件的输入流
					zipOut.putNextEntry(new ZipEntry(file.getName()
						+File.separator+lists[i].getName())) ;	// 设置ZipEntry对象
					System.out.println("正在压缩" + lists[i].getName());
					while((temp=input.read())!=-1){	// 读取内容
						zipOut.write(temp) ;	// 压缩输出
					}
					input.close() ;	// 关闭输入流
				}
			}
			zipOut.close() ;	// 关闭输出流
			System.out.println("multiple file zip done.");
		}
	}

***

		import java.io.File ;  
	import java.io.FileInputStream ;
	import java.io.FileOutputStream;
	import java.io.OutputStream;
	import java.util.zip.ZipEntry ;  
	import java.util.zip.ZipInputStream ;   
	public class SingleFileUnzip{  
	    public static void main(String args[]) throws Exception{     
	        //待解压文件, 需要从zip文件打开输入流，读取数据到java中
	    	File zipFile = new File("c:/temp/single.zip") ;   // 定义压缩文件名称          
	        ZipInputStream input = null ;   // 定义压缩输入流  
	        input = new ZipInputStream(new FileInputStream(zipFile)) ;  // 实例化ZIpInputStream  
	        ZipEntry entry = input.getNextEntry() ; // 得到一个压缩实体  
	        System.out.println("压缩实体名称：" + entry.getName()) ;  //获取压缩包中文件名字 
	        
	        //新建目标文件，需要从目标文件打开输出流，数据从java流入
	        File outFile = new File("c:/temp/" + entry.getName());
	        OutputStream out = new FileOutputStream(outFile) ;   // 实例化文件输出流  
	        int temp = 0 ;  
	        while((temp=input.read())!=-1){  
	            out.write(temp) ;  
	        }  
	        input.close() ;     // 关闭输入流  
	        out.close() ;   // 关闭输出流
	        System.out.println("unzip done.") ;
	    }  
	}

***

		
	import java.io.File ;  
	import java.io.FileInputStream ;  
	import java.io.InputStream ;  
	import java.util.zip.ZipEntry ;  
	import java.util.zip.ZipOutputStream ;  
	import java.io.FileOutputStream ;  
	public class SingleFileZip{  
	    public static void main(String args[]) throws Exception{    
	        File file = new File("c:/temp/abc.txt") ;  // 定义要压缩的文件  
	        File zipFile = new File("c:/temp/single2.zip") ;   // 定义压缩文件名称  
	        
	        InputStream input = new FileInputStream(file) ; // 定义文件的输入流  
	        ZipOutputStream zipOut = null ; // 声明压缩流对象  
	        zipOut = new ZipOutputStream(new FileOutputStream(zipFile)) ;  
	        zipOut.putNextEntry(new ZipEntry(file.getName())) ; // 设置ZipEntry对象  
	        zipOut.setComment("single file zip") ;  // 设置注释  
	        
	        //压缩过程
	        int temp = 0 ;  
	        while((temp=input.read())!=-1){ // 读取内容  
	            zipOut.write(temp) ;    // 压缩输出  
	        }  
	        input.close() ; // 关闭输入流  
	        zipOut.close() ;    // 关闭输出流  
	        
	        System.out.println("single file zip done.");
	    }  
	}
tu